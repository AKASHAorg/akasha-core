# This file was generated. Do not edit manually.

schema {
  query: Query
  mutation: Mutation
}

interface AkashaAppInterface {
  "Account controlling the document"
  author: CeramicAccount!
  contributors: [CeramicAccount]
  coverImage: AppImageSource
  createdAt: DateTime!
  description: String!
  displayName: String!
  gallery: [AppImageSource]
  id: ID!
  keywords: [String]
  license: String!
  links: [AppLinkSource]
  logoImage: AppImageSource
  meta: [AppProviderValue]
  name: String!
  nsfw: Boolean
  "Current version of the document"
  version: CeramicCommitID!
}

interface AkashaAppReleaseInterface {
  application: AkashaAppInterface
  applicationID: CeramicStreamID!
  createdAt: DateTime!
  id: ID!
  meta: [AppProviderValue]
  source: URI!
  version: String!
}

interface AkashaBeamInterface {
  active: Boolean!
  app: AkashaAppInterface
  appID: CeramicStreamID!
  appVersion: AkashaAppReleaseInterface
  appVersionID: CeramicStreamID!
  "Account controlling the document"
  author: CeramicAccount!
  content: [BeamBlockRecord!]!
  createdAt: DateTime!
  embeddedStream: BeamEmbeddedType
  id: ID!
  mentions: [CeramicAccount]
  nsfw: Boolean
  tags: [BeamLabeled]
  "Current version of the document"
  version: CeramicCommitID!
}

interface AkashaContentBlockInterface {
  active: Boolean!
  appVersion: AkashaAppReleaseInterface
  appVersionID: CeramicStreamID!
  "Account controlling the document"
  author: CeramicAccount!
  content: [BlockLabeledValue!]!
  createdAt: DateTime!
  id: ID!
  nsfw: Boolean
  "Current version of the document"
  version: CeramicCommitID!
}

interface AkashaFollowInterface {
  "Account controlling the document"
  did: CeramicAccount!
  id: ID!
  isFollowing: Boolean!
  profile: AkashaProfileInterface
  profileID: CeramicStreamID!
}

interface AkashaIndexStreamInterface {
  active: Boolean!
  createdAt: DateTime!
  id: ID!
  moderation: Node
  moderationID: CeramicStreamID
}

interface AkashaProfileInterestsInterface {
  "Account controlling the document"
  did: CeramicAccount!
  id: ID!
  topics: [ProfileLabeled!]!
}

interface AkashaProfileInterface {
  app: AkashaAppInterface
  appID: CeramicStreamID!
  appVersion: AkashaAppReleaseInterface
  appVersionID: CeramicStreamID!
  avatar: ProfileImageVersions
  background: ProfileImageVersions
  createdAt: DateTime!
  description: String
  "Account controlling the document"
  did: CeramicAccount!
  id: ID!
  links: [ProfileLinkSource]
  name: String!
  nsfw: Boolean
}

interface AkashaReflectInterface {
  active: Boolean!
  "Account controlling the document"
  author: CeramicAccount!
  beam: AkashaBeamInterface
  beamID: CeramicStreamID!
  content: [ReflectProviderValue!]!
  createdAt: DateTime!
  id: ID!
  isReply: Boolean
  mentions: [CeramicStreamID]
  nsfw: Boolean
  reflection: CeramicStreamID
  reflectionView: Node
  tags: [String]
  "Current version of the document"
  version: CeramicCommitID!
}

"An object with an ID"
interface Node {
  "The id of the object."
  id: ID!
}

type AkashaApp implements AkashaAppInterface & Node {
  applicationType: AkashaAppApplicationType
  "Account controlling the document"
  author: CeramicAccount!
  contributors: [CeramicAccount]
  coverImage: AppImageSource
  createdAt: DateTime!
  description: String!
  displayName: String!
  gallery: [AppImageSource]
  id: ID!
  keywords: [String]
  license: String!
  links: [AppLinkSource]
  logoImage: AppImageSource
  meta: [AppProviderValue]
  name: String!
  nsfw: Boolean
  releases(
    "Returns only documents created by the provided account"
    account: ID,
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaAppReleaseInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaAppReleaseInterfaceSortingInput
  ): AkashaAppReleaseInterfaceConnection!
  releasesCount(
    "Counts only documents created by the provided account"
    account: ID,
    filters: AkashaAppReleaseInterfaceFiltersInput
  ): Int!
  "Current version of the document"
  version: CeramicCommitID!
}

"A connection to a list of items."
type AkashaAppConnection {
  "A list of edges."
  edges: [AkashaAppEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaAppEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaApp
}

"A connection to a list of items."
type AkashaAppInterfaceConnection {
  "A list of edges."
  edges: [AkashaAppInterfaceEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaAppInterfaceEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaAppInterface
}

type AkashaAppRelease implements AkashaAppReleaseInterface & Node {
  application: AkashaAppInterface
  applicationID: CeramicStreamID!
  createdAt: DateTime!
  id: ID!
  meta: [AppProviderValue]
  source: URI!
  version: String!
}

"A connection to a list of items."
type AkashaAppReleaseConnection {
  "A list of edges."
  edges: [AkashaAppReleaseEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaAppReleaseEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaAppRelease
}

"A connection to a list of items."
type AkashaAppReleaseInterfaceConnection {
  "A list of edges."
  edges: [AkashaAppReleaseInterfaceEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaAppReleaseInterfaceEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaAppReleaseInterface
}

type AkashaAppsStream implements AkashaIndexStreamInterface & Node {
  active: Boolean!
  application: AkashaAppInterface
  applicationID: CeramicStreamID!
  createdAt: DateTime!
  id: ID!
  moderation: Node
  moderationID: CeramicStreamID
  status: AkashaAppsStreamModerationStatus
}

"A connection to a list of items."
type AkashaAppsStreamConnection {
  "A list of edges."
  edges: [AkashaAppsStreamEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaAppsStreamEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaAppsStream
}

type AkashaBeam implements AkashaBeamInterface & Node {
  active: Boolean!
  app: AkashaAppInterface
  appID: CeramicStreamID!
  appVersion: AkashaAppReleaseInterface
  appVersionID: CeramicStreamID!
  "Account controlling the document"
  author: CeramicAccount!
  content: [BeamBlockRecord!]!
  createdAt: DateTime!
  embeddedStream: BeamEmbeddedType
  id: ID!
  mentions: [CeramicAccount]
  nsfw: Boolean
  reflections(
    "Returns only documents created by the provided account"
    account: ID,
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaReflectInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaReflectInterfaceSortingInput
  ): AkashaReflectInterfaceConnection!
  reflectionsCount(
    "Counts only documents created by the provided account"
    account: ID,
    filters: AkashaReflectInterfaceFiltersInput
  ): Int!
  tags: [BeamLabeled]
  "Current version of the document"
  version: CeramicCommitID!
}

"A connection to a list of items."
type AkashaBeamConnection {
  "A list of edges."
  edges: [AkashaBeamEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaBeamEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaBeam
}

"A connection to a list of items."
type AkashaBeamInterfaceConnection {
  "A list of edges."
  edges: [AkashaBeamInterfaceEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaBeamInterfaceEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaBeamInterface
}

type AkashaBeamStream implements AkashaIndexStreamInterface & Node {
  active: Boolean!
  appID: CeramicStreamID
  beam: AkashaBeamInterface
  beamID: CeramicStreamID!
  createdAt: DateTime!
  id: ID!
  moderation: Node
  moderationID: CeramicStreamID
  status: AkashaBeamStreamModerationStatus
}

"A connection to a list of items."
type AkashaBeamStreamConnection {
  "A list of edges."
  edges: [AkashaBeamStreamEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaBeamStreamEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaBeamStream
}

type AkashaBlockStorage implements AkashaContentBlockInterface & Node {
  active: Boolean!
  appVersion: AkashaAppReleaseInterface
  appVersionID: CeramicStreamID!
  "Account controlling the document"
  author: CeramicAccount!
  block: AkashaContentBlock
  blockID: CeramicStreamID!
  content: [BlockLabeledValue!]!
  createdAt: DateTime!
  id: ID!
  kind: AkashaBlockStorageBlockDef
  nsfw: Boolean
  "Current version of the document"
  version: CeramicCommitID!
}

"A connection to a list of items."
type AkashaBlockStorageConnection {
  "A list of edges."
  edges: [AkashaBlockStorageEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaBlockStorageEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaBlockStorage
}

type AkashaContentBlock implements AkashaContentBlockInterface & Node {
  active: Boolean!
  appVersion: AkashaAppReleaseInterface
  appVersionID: CeramicStreamID!
  "Account controlling the document"
  author: CeramicAccount!
  content: [BlockLabeledValue!]!
  createdAt: DateTime!
  id: ID!
  kind: AkashaContentBlockBlockDef
  nsfw: Boolean
  "Current version of the document"
  version: CeramicCommitID!
}

"A connection to a list of items."
type AkashaContentBlockConnection {
  "A list of edges."
  edges: [AkashaContentBlockEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaContentBlockEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaContentBlock
}

"A connection to a list of items."
type AkashaContentBlockInterfaceConnection {
  "A list of edges."
  edges: [AkashaContentBlockInterfaceEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaContentBlockInterfaceEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaContentBlockInterface
}

type AkashaContentBlockStream implements AkashaIndexStreamInterface & Node {
  active: Boolean!
  block: AkashaContentBlockInterface
  blockID: CeramicStreamID!
  createdAt: DateTime!
  id: ID!
  moderation: Node
  moderationID: CeramicStreamID
  status: AkashaContentBlockStreamModerationStatus
}

"A connection to a list of items."
type AkashaContentBlockStreamConnection {
  "A list of edges."
  edges: [AkashaContentBlockStreamEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaContentBlockStreamEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaContentBlockStream
}

type AkashaFollow implements AkashaFollowInterface & Node {
  "Account controlling the document"
  did: CeramicAccount!
  id: ID!
  isFollowing: Boolean!
  profile: AkashaProfileInterface
  profileID: CeramicStreamID!
}

"A connection to a list of items."
type AkashaFollowConnection {
  "A list of edges."
  edges: [AkashaFollowEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaFollowEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaFollow
}

"A connection to a list of items."
type AkashaFollowInterfaceConnection {
  "A list of edges."
  edges: [AkashaFollowInterfaceEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaFollowInterfaceEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaFollowInterface
}

"A connection to a list of items."
type AkashaIndexStreamInterfaceConnection {
  "A list of edges."
  edges: [AkashaIndexStreamInterfaceEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaIndexStreamInterfaceEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaIndexStreamInterface
}

type AkashaIndexedStream implements AkashaIndexStreamInterface & Node {
  active: Boolean!
  createdAt: DateTime!
  id: ID!
  indexType: String!
  indexValue: String!
  moderation: Node
  moderationID: CeramicStreamID
  status: AkashaIndexedStreamModerationStatus
  stream: CeramicStreamID!
  streamType: AkashaIndexedStreamStreamType
  streamView: Node
}

"A connection to a list of items."
type AkashaIndexedStreamConnection {
  "A list of edges."
  edges: [AkashaIndexedStreamEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaIndexedStreamEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaIndexedStream
}

type AkashaInterestsStream implements AkashaIndexStreamInterface & Node {
  active: Boolean!
  createdAt: DateTime!
  id: ID!
  labelType: String!
  moderation: Node
  moderationID: CeramicStreamID
  status: AkashaInterestsStreamModerationStatus
  value: String!
}

"A connection to a list of items."
type AkashaInterestsStreamConnection {
  "A list of edges."
  edges: [AkashaInterestsStreamEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaInterestsStreamEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaInterestsStream
}

type AkashaProfile implements AkashaProfileInterface & Node {
  app: AkashaAppInterface
  appID: CeramicStreamID!
  appVersion: AkashaAppReleaseInterface
  appVersionID: CeramicStreamID!
  avatar: ProfileImageVersions
  background: ProfileImageVersions
  createdAt: DateTime!
  description: String
  "Account controlling the document"
  did: CeramicAccount!
  followers(
    "Returns only documents created by the provided account"
    account: ID,
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaFollowInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaFollowInterfaceSortingInput
  ): AkashaFollowInterfaceConnection!
  followersCount(
    "Counts only documents created by the provided account"
    account: ID,
    filters: AkashaFollowInterfaceFiltersInput
  ): Int!
  id: ID!
  links: [ProfileLinkSource]
  name: String!
  nsfw: Boolean
}

"A connection to a list of items."
type AkashaProfileConnection {
  "A list of edges."
  edges: [AkashaProfileEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaProfileEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaProfile
}

type AkashaProfileInterests implements AkashaProfileInterestsInterface & Node {
  "Account controlling the document"
  did: CeramicAccount!
  id: ID!
  topics: [ProfileLabeled!]!
}

"A connection to a list of items."
type AkashaProfileInterestsConnection {
  "A list of edges."
  edges: [AkashaProfileInterestsEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaProfileInterestsEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaProfileInterests
}

"A connection to a list of items."
type AkashaProfileInterestsInterfaceConnection {
  "A list of edges."
  edges: [AkashaProfileInterestsInterfaceEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaProfileInterestsInterfaceEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaProfileInterestsInterface
}

"A connection to a list of items."
type AkashaProfileInterfaceConnection {
  "A list of edges."
  edges: [AkashaProfileInterfaceEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaProfileInterfaceEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaProfileInterface
}

type AkashaProfileStream implements AkashaIndexStreamInterface & Node {
  active: Boolean!
  appID: CeramicStreamID
  createdAt: DateTime!
  id: ID!
  moderation: Node
  moderationID: CeramicStreamID
  profile: AkashaProfileInterface
  profileID: CeramicStreamID!
  status: AkashaProfileStreamModerationStatus
}

"A connection to a list of items."
type AkashaProfileStreamConnection {
  "A list of edges."
  edges: [AkashaProfileStreamEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaProfileStreamEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaProfileStream
}

type AkashaReflect implements AkashaReflectInterface & Node {
  active: Boolean!
  "Account controlling the document"
  author: CeramicAccount!
  beam: AkashaBeamInterface
  beamID: CeramicStreamID!
  content: [ReflectProviderValue!]!
  createdAt: DateTime!
  id: ID!
  isReply: Boolean
  mentions: [CeramicStreamID]
  nsfw: Boolean
  reflection: CeramicStreamID
  reflectionView: Node
  tags: [String]
  "Current version of the document"
  version: CeramicCommitID!
}

"A connection to a list of items."
type AkashaReflectConnection {
  "A list of edges."
  edges: [AkashaReflectEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaReflectEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaReflect
}

"A connection to a list of items."
type AkashaReflectInterfaceConnection {
  "A list of edges."
  edges: [AkashaReflectInterfaceEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaReflectInterfaceEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaReflectInterface
}

type AkashaReflectStream implements AkashaIndexStreamInterface & Node {
  active: Boolean!
  beamID: CeramicStreamID!
  createdAt: DateTime!
  id: ID!
  isReply: Boolean
  moderation: Node
  moderationID: CeramicStreamID
  reflection: AkashaReflectInterface
  reflectionID: CeramicStreamID!
  replyTo: CeramicStreamID
  status: AkashaReflectStreamModerationStatus
}

"A connection to a list of items."
type AkashaReflectStreamConnection {
  "A list of edges."
  edges: [AkashaReflectStreamEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaReflectStreamEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaReflectStream
}

type AppImageSource {
  height: Int
  src: URI!
  width: Int
}

type AppLinkSource {
  href: URI!
  label: String
}

type AppProviderValue {
  property: String!
  provider: String!
  value: String!
}

type BeamBlockRecord {
  blockID: CeramicStreamID!
  order: Int!
}

type BeamEmbeddedType {
  embeddedID: CeramicStreamID!
  label: String!
}

type BeamLabeled {
  labelType: String!
  value: String!
}

type BlockLabeledValue {
  label: String!
  propertyType: String!
  value: String!
}

type CeramicAccount implements Node {
  akashaApp(with: WithAkashaAppInput!): AkashaApp
  akashaAppInterfaceList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaAppInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaAppInterfaceSortingInput
  ): AkashaAppInterfaceConnection
  akashaAppInterfaceListCount(filters: AkashaAppInterfaceFiltersInput): Int!
  akashaAppList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaAppFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaAppSortingInput
  ): AkashaAppConnection
  akashaAppListCount(filters: AkashaAppFiltersInput): Int!
  akashaAppRelease(with: WithAkashaAppReleaseInput!): AkashaAppRelease
  akashaAppReleaseInterfaceList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaAppReleaseInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaAppReleaseInterfaceSortingInput
  ): AkashaAppReleaseInterfaceConnection
  akashaAppReleaseInterfaceListCount(filters: AkashaAppReleaseInterfaceFiltersInput): Int!
  akashaAppReleaseList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaAppReleaseFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaAppReleaseSortingInput
  ): AkashaAppReleaseConnection
  akashaAppReleaseListCount(filters: AkashaAppReleaseFiltersInput): Int!
  akashaAppsStream(with: WithAkashaAppsStreamInput!): AkashaAppsStream
  akashaAppsStreamList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaAppsStreamFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaAppsStreamSortingInput
  ): AkashaAppsStreamConnection
  akashaAppsStreamListCount(filters: AkashaAppsStreamFiltersInput): Int!
  akashaBeamInterfaceList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaBeamInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaBeamInterfaceSortingInput
  ): AkashaBeamInterfaceConnection
  akashaBeamInterfaceListCount(filters: AkashaBeamInterfaceFiltersInput): Int!
  akashaBeamList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaBeamFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaBeamSortingInput
  ): AkashaBeamConnection
  akashaBeamListCount(filters: AkashaBeamFiltersInput): Int!
  akashaBeamStream(with: WithAkashaBeamStreamInput!): AkashaBeamStream
  akashaBeamStreamList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaBeamStreamFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaBeamStreamSortingInput
  ): AkashaBeamStreamConnection
  akashaBeamStreamListCount(filters: AkashaBeamStreamFiltersInput): Int!
  akashaBlockStorage(with: WithAkashaBlockStorageInput!): AkashaBlockStorage
  akashaBlockStorageList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaBlockStorageFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaBlockStorageSortingInput
  ): AkashaBlockStorageConnection
  akashaBlockStorageListCount(filters: AkashaBlockStorageFiltersInput): Int!
  akashaContentBlockInterfaceList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaContentBlockInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaContentBlockInterfaceSortingInput
  ): AkashaContentBlockInterfaceConnection
  akashaContentBlockInterfaceListCount(filters: AkashaContentBlockInterfaceFiltersInput): Int!
  akashaContentBlockList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaContentBlockFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaContentBlockSortingInput
  ): AkashaContentBlockConnection
  akashaContentBlockListCount(filters: AkashaContentBlockFiltersInput): Int!
  akashaContentBlockStream(with: WithAkashaContentBlockStreamInput!): AkashaContentBlockStream
  akashaContentBlockStreamList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaContentBlockStreamFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaContentBlockStreamSortingInput
  ): AkashaContentBlockStreamConnection
  akashaContentBlockStreamListCount(filters: AkashaContentBlockStreamFiltersInput): Int!
  akashaFollow(with: WithAkashaFollowInput!): AkashaFollow
  akashaFollowInterfaceList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaFollowInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaFollowInterfaceSortingInput
  ): AkashaFollowInterfaceConnection
  akashaFollowInterfaceListCount(filters: AkashaFollowInterfaceFiltersInput): Int!
  akashaFollowList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaFollowFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaFollowSortingInput
  ): AkashaFollowConnection
  akashaFollowListCount(filters: AkashaFollowFiltersInput): Int!
  akashaIndexStreamInterfaceList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaIndexStreamInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaIndexStreamInterfaceSortingInput
  ): AkashaIndexStreamInterfaceConnection
  akashaIndexStreamInterfaceListCount(filters: AkashaIndexStreamInterfaceFiltersInput): Int!
  akashaIndexedStream(with: WithAkashaIndexedStreamInput!): AkashaIndexedStream
  akashaIndexedStreamList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaIndexedStreamFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaIndexedStreamSortingInput
  ): AkashaIndexedStreamConnection
  akashaIndexedStreamListCount(filters: AkashaIndexedStreamFiltersInput): Int!
  akashaInterestsStream(with: WithAkashaInterestsStreamInput!): AkashaInterestsStream
  akashaInterestsStreamList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaInterestsStreamFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaInterestsStreamSortingInput
  ): AkashaInterestsStreamConnection
  akashaInterestsStreamListCount(filters: AkashaInterestsStreamFiltersInput): Int!
  akashaProfile: AkashaProfile
  akashaProfileInterests: AkashaProfileInterests
  akashaProfileInterestsInterfaceList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int
  ): AkashaProfileInterestsInterfaceConnection
  akashaProfileInterestsInterfaceListCount: Int!
  akashaProfileInterfaceList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaProfileInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaProfileInterfaceSortingInput
  ): AkashaProfileInterfaceConnection
  akashaProfileInterfaceListCount(filters: AkashaProfileInterfaceFiltersInput): Int!
  akashaProfileStream(with: WithAkashaProfileStreamInput!): AkashaProfileStream
  akashaProfileStreamList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaProfileStreamFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaProfileStreamSortingInput
  ): AkashaProfileStreamConnection
  akashaProfileStreamListCount(filters: AkashaProfileStreamFiltersInput): Int!
  akashaReflectInterfaceList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaReflectInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaReflectInterfaceSortingInput
  ): AkashaReflectInterfaceConnection
  akashaReflectInterfaceListCount(filters: AkashaReflectInterfaceFiltersInput): Int!
  akashaReflectList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaReflectFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaReflectSortingInput
  ): AkashaReflectConnection
  akashaReflectListCount(filters: AkashaReflectFiltersInput): Int!
  akashaReflectStream(with: WithAkashaReflectStreamInput!): AkashaReflectStream
  akashaReflectStreamList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaReflectStreamFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaReflectStreamSortingInput
  ): AkashaReflectStreamConnection
  akashaReflectStreamListCount(filters: AkashaReflectStreamFiltersInput): Int!
  "Globally unique identifier of the account (DID string)"
  id: ID!
  "Whether the Ceramic instance is currently authenticated with this account or not"
  isViewer: Boolean!
}

type CreateAkashaBeamPayload {
  clientMutationId: String
  document: AkashaBeam!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type CreateAkashaContentBlockPayload {
  clientMutationId: String
  document: AkashaContentBlock!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type CreateAkashaProfileInterestsPayload {
  clientMutationId: String
  document: AkashaProfileInterests!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type CreateAkashaProfilePayload {
  clientMutationId: String
  document: AkashaProfile!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type CreateAkashaReflectPayload {
  clientMutationId: String
  document: AkashaReflect!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type EnableIndexingAkashaAppPayload {
  clientMutationId: String
  document: AkashaApp
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type EnableIndexingAkashaAppReleasePayload {
  clientMutationId: String
  document: AkashaAppRelease
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type EnableIndexingAkashaAppsStreamPayload {
  clientMutationId: String
  document: AkashaAppsStream
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type EnableIndexingAkashaBeamPayload {
  clientMutationId: String
  document: AkashaBeam
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type EnableIndexingAkashaBeamStreamPayload {
  clientMutationId: String
  document: AkashaBeamStream
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type EnableIndexingAkashaBlockStoragePayload {
  clientMutationId: String
  document: AkashaBlockStorage
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type EnableIndexingAkashaContentBlockPayload {
  clientMutationId: String
  document: AkashaContentBlock
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type EnableIndexingAkashaContentBlockStreamPayload {
  clientMutationId: String
  document: AkashaContentBlockStream
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type EnableIndexingAkashaFollowPayload {
  clientMutationId: String
  document: AkashaFollow
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type EnableIndexingAkashaIndexedStreamPayload {
  clientMutationId: String
  document: AkashaIndexedStream
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type EnableIndexingAkashaInterestsStreamPayload {
  clientMutationId: String
  document: AkashaInterestsStream
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type EnableIndexingAkashaProfileInterestsPayload {
  clientMutationId: String
  document: AkashaProfileInterests
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type EnableIndexingAkashaProfilePayload {
  clientMutationId: String
  document: AkashaProfile
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type EnableIndexingAkashaProfileStreamPayload {
  clientMutationId: String
  document: AkashaProfileStream
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type EnableIndexingAkashaReflectPayload {
  clientMutationId: String
  document: AkashaReflect
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type EnableIndexingAkashaReflectStreamPayload {
  clientMutationId: String
  document: AkashaReflectStream
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type Mutation {
  createAkashaBeam(input: CreateAkashaBeamInput!): CreateAkashaBeamPayload
  createAkashaContentBlock(input: CreateAkashaContentBlockInput!): CreateAkashaContentBlockPayload
  createAkashaProfile(input: CreateAkashaProfileInput!): CreateAkashaProfilePayload @deprecated(reason: "Replaced by the setAkashaProfile mutation, createAkashaProfile will be removed in a future version of ComposeDB.")
  createAkashaProfileInterests(input: CreateAkashaProfileInterestsInput!): CreateAkashaProfileInterestsPayload @deprecated(reason: "Replaced by the setAkashaProfileInterests mutation, createAkashaProfileInterests will be removed in a future version of ComposeDB.")
  createAkashaReflect(input: CreateAkashaReflectInput!): CreateAkashaReflectPayload
  enableIndexingAkashaApp(input: EnableIndexingAkashaAppInput!): EnableIndexingAkashaAppPayload
  enableIndexingAkashaAppRelease(input: EnableIndexingAkashaAppReleaseInput!): EnableIndexingAkashaAppReleasePayload
  enableIndexingAkashaAppsStream(input: EnableIndexingAkashaAppsStreamInput!): EnableIndexingAkashaAppsStreamPayload
  enableIndexingAkashaBeam(input: EnableIndexingAkashaBeamInput!): EnableIndexingAkashaBeamPayload
  enableIndexingAkashaBeamStream(input: EnableIndexingAkashaBeamStreamInput!): EnableIndexingAkashaBeamStreamPayload
  enableIndexingAkashaBlockStorage(input: EnableIndexingAkashaBlockStorageInput!): EnableIndexingAkashaBlockStoragePayload
  enableIndexingAkashaContentBlock(input: EnableIndexingAkashaContentBlockInput!): EnableIndexingAkashaContentBlockPayload
  enableIndexingAkashaContentBlockStream(input: EnableIndexingAkashaContentBlockStreamInput!): EnableIndexingAkashaContentBlockStreamPayload
  enableIndexingAkashaFollow(input: EnableIndexingAkashaFollowInput!): EnableIndexingAkashaFollowPayload
  enableIndexingAkashaIndexedStream(input: EnableIndexingAkashaIndexedStreamInput!): EnableIndexingAkashaIndexedStreamPayload
  enableIndexingAkashaInterestsStream(input: EnableIndexingAkashaInterestsStreamInput!): EnableIndexingAkashaInterestsStreamPayload
  enableIndexingAkashaProfile(input: EnableIndexingAkashaProfileInput!): EnableIndexingAkashaProfilePayload
  enableIndexingAkashaProfileInterests(input: EnableIndexingAkashaProfileInterestsInput!): EnableIndexingAkashaProfileInterestsPayload
  enableIndexingAkashaProfileStream(input: EnableIndexingAkashaProfileStreamInput!): EnableIndexingAkashaProfileStreamPayload
  enableIndexingAkashaReflect(input: EnableIndexingAkashaReflectInput!): EnableIndexingAkashaReflectPayload
  enableIndexingAkashaReflectStream(input: EnableIndexingAkashaReflectStreamInput!): EnableIndexingAkashaReflectStreamPayload
  setAkashaApp(input: SetAkashaAppInput!): SetAkashaAppPayload
  setAkashaAppRelease(input: SetAkashaAppReleaseInput!): SetAkashaAppReleasePayload
  setAkashaAppsStream(input: SetAkashaAppsStreamInput!): SetAkashaAppsStreamPayload
  setAkashaBeamStream(input: SetAkashaBeamStreamInput!): SetAkashaBeamStreamPayload
  setAkashaBlockStorage(input: SetAkashaBlockStorageInput!): SetAkashaBlockStoragePayload
  setAkashaContentBlockStream(input: SetAkashaContentBlockStreamInput!): SetAkashaContentBlockStreamPayload
  setAkashaFollow(input: SetAkashaFollowInput!): SetAkashaFollowPayload
  setAkashaIndexedStream(input: SetAkashaIndexedStreamInput!): SetAkashaIndexedStreamPayload
  setAkashaInterestsStream(input: SetAkashaInterestsStreamInput!): SetAkashaInterestsStreamPayload
  setAkashaProfile(input: SetAkashaProfileInput!): SetAkashaProfilePayload
  setAkashaProfileInterests(input: SetAkashaProfileInterestsInput!): SetAkashaProfileInterestsPayload
  setAkashaProfileStream(input: SetAkashaProfileStreamInput!): SetAkashaProfileStreamPayload
  setAkashaReflectStream(input: SetAkashaReflectStreamInput!): SetAkashaReflectStreamPayload
  updateAkashaApp(input: UpdateAkashaAppInput!): UpdateAkashaAppPayload
  updateAkashaAppRelease(input: UpdateAkashaAppReleaseInput!): UpdateAkashaAppReleasePayload
  updateAkashaAppsStream(input: UpdateAkashaAppsStreamInput!): UpdateAkashaAppsStreamPayload
  updateAkashaBeam(input: UpdateAkashaBeamInput!): UpdateAkashaBeamPayload
  updateAkashaBeamStream(input: UpdateAkashaBeamStreamInput!): UpdateAkashaBeamStreamPayload
  updateAkashaBlockStorage(input: UpdateAkashaBlockStorageInput!): UpdateAkashaBlockStoragePayload
  updateAkashaContentBlock(input: UpdateAkashaContentBlockInput!): UpdateAkashaContentBlockPayload
  updateAkashaContentBlockStream(input: UpdateAkashaContentBlockStreamInput!): UpdateAkashaContentBlockStreamPayload
  updateAkashaFollow(input: UpdateAkashaFollowInput!): UpdateAkashaFollowPayload
  updateAkashaIndexedStream(input: UpdateAkashaIndexedStreamInput!): UpdateAkashaIndexedStreamPayload
  updateAkashaInterestsStream(input: UpdateAkashaInterestsStreamInput!): UpdateAkashaInterestsStreamPayload
  updateAkashaProfile(input: UpdateAkashaProfileInput!): UpdateAkashaProfilePayload
  updateAkashaProfileInterests(input: UpdateAkashaProfileInterestsInput!): UpdateAkashaProfileInterestsPayload
  updateAkashaProfileStream(input: UpdateAkashaProfileStreamInput!): UpdateAkashaProfileStreamPayload
  updateAkashaReflect(input: UpdateAkashaReflectInput!): UpdateAkashaReflectPayload
  updateAkashaReflectStream(input: UpdateAkashaReflectStreamInput!): UpdateAkashaReflectStreamPayload
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

type ProfileImageSource {
  height: Int!
  src: URI!
  width: Int!
}

type ProfileImageVersions {
  alternatives: [ProfileImageSource]
  default: ProfileImageSource!
}

type ProfileLabeled {
  labelType: String!
  value: String!
}

type ProfileLinkSource {
  href: URI!
  label: String
}

type Query {
  akashaAppCount(filters: AkashaAppFiltersInput): Int!
  akashaAppIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaAppFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaAppSortingInput
  ): AkashaAppConnection
  akashaAppInterfaceCount(filters: AkashaAppInterfaceFiltersInput): Int!
  akashaAppInterfaceIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaAppInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaAppInterfaceSortingInput
  ): AkashaAppInterfaceConnection
  akashaAppReleaseCount(filters: AkashaAppReleaseFiltersInput): Int!
  akashaAppReleaseIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaAppReleaseFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaAppReleaseSortingInput
  ): AkashaAppReleaseConnection
  akashaAppReleaseInterfaceCount(filters: AkashaAppReleaseInterfaceFiltersInput): Int!
  akashaAppReleaseInterfaceIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaAppReleaseInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaAppReleaseInterfaceSortingInput
  ): AkashaAppReleaseInterfaceConnection
  akashaAppsStreamCount(filters: AkashaAppsStreamFiltersInput): Int!
  akashaAppsStreamIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaAppsStreamFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaAppsStreamSortingInput
  ): AkashaAppsStreamConnection
  akashaBeamCount(filters: AkashaBeamFiltersInput): Int!
  akashaBeamIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaBeamFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaBeamSortingInput
  ): AkashaBeamConnection
  akashaBeamInterfaceCount(filters: AkashaBeamInterfaceFiltersInput): Int!
  akashaBeamInterfaceIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaBeamInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaBeamInterfaceSortingInput
  ): AkashaBeamInterfaceConnection
  akashaBeamStreamCount(filters: AkashaBeamStreamFiltersInput): Int!
  akashaBeamStreamIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaBeamStreamFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaBeamStreamSortingInput
  ): AkashaBeamStreamConnection
  akashaBlockStorageCount(filters: AkashaBlockStorageFiltersInput): Int!
  akashaBlockStorageIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaBlockStorageFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaBlockStorageSortingInput
  ): AkashaBlockStorageConnection
  akashaContentBlockCount(filters: AkashaContentBlockFiltersInput): Int!
  akashaContentBlockIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaContentBlockFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaContentBlockSortingInput
  ): AkashaContentBlockConnection
  akashaContentBlockInterfaceCount(filters: AkashaContentBlockInterfaceFiltersInput): Int!
  akashaContentBlockInterfaceIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaContentBlockInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaContentBlockInterfaceSortingInput
  ): AkashaContentBlockInterfaceConnection
  akashaContentBlockStreamCount(filters: AkashaContentBlockStreamFiltersInput): Int!
  akashaContentBlockStreamIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaContentBlockStreamFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaContentBlockStreamSortingInput
  ): AkashaContentBlockStreamConnection
  akashaFollowCount(filters: AkashaFollowFiltersInput): Int!
  akashaFollowIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaFollowFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaFollowSortingInput
  ): AkashaFollowConnection
  akashaFollowInterfaceCount(filters: AkashaFollowInterfaceFiltersInput): Int!
  akashaFollowInterfaceIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaFollowInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaFollowInterfaceSortingInput
  ): AkashaFollowInterfaceConnection
  akashaIndexStreamInterfaceCount(filters: AkashaIndexStreamInterfaceFiltersInput): Int!
  akashaIndexStreamInterfaceIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaIndexStreamInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaIndexStreamInterfaceSortingInput
  ): AkashaIndexStreamInterfaceConnection
  akashaIndexedStreamCount(filters: AkashaIndexedStreamFiltersInput): Int!
  akashaIndexedStreamIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaIndexedStreamFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaIndexedStreamSortingInput
  ): AkashaIndexedStreamConnection
  akashaInterestsStreamCount(filters: AkashaInterestsStreamFiltersInput): Int!
  akashaInterestsStreamIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaInterestsStreamFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaInterestsStreamSortingInput
  ): AkashaInterestsStreamConnection
  akashaProfileCount(filters: AkashaProfileFiltersInput): Int!
  akashaProfileIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaProfileFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaProfileSortingInput
  ): AkashaProfileConnection
  akashaProfileInterestsCount: Int!
  akashaProfileInterestsIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int
  ): AkashaProfileInterestsConnection
  akashaProfileInterestsInterfaceCount: Int!
  akashaProfileInterestsInterfaceIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int
  ): AkashaProfileInterestsInterfaceConnection
  akashaProfileInterfaceCount(filters: AkashaProfileInterfaceFiltersInput): Int!
  akashaProfileInterfaceIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaProfileInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaProfileInterfaceSortingInput
  ): AkashaProfileInterfaceConnection
  akashaProfileStreamCount(filters: AkashaProfileStreamFiltersInput): Int!
  akashaProfileStreamIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaProfileStreamFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaProfileStreamSortingInput
  ): AkashaProfileStreamConnection
  akashaReflectCount(filters: AkashaReflectFiltersInput): Int!
  akashaReflectIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaReflectFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaReflectSortingInput
  ): AkashaReflectConnection
  akashaReflectInterfaceCount(filters: AkashaReflectInterfaceFiltersInput): Int!
  akashaReflectInterfaceIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaReflectInterfaceFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaReflectInterfaceSortingInput
  ): AkashaReflectInterfaceConnection
  akashaReflectStreamCount(filters: AkashaReflectStreamFiltersInput): Int!
  akashaReflectStreamIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaReflectStreamFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaReflectStreamSortingInput
  ): AkashaReflectStreamConnection
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Fetches objects given their IDs"
  nodes(
    "The IDs of objects"
    ids: [ID!]!
  ): [Node]!
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type ReflectProviderValue {
  label: String!
  propertyType: String!
  value: String!
}

type SetAkashaAppPayload {
  clientMutationId: String
  document: AkashaApp!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type SetAkashaAppReleasePayload {
  clientMutationId: String
  document: AkashaAppRelease!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type SetAkashaAppsStreamPayload {
  clientMutationId: String
  document: AkashaAppsStream!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type SetAkashaBeamStreamPayload {
  clientMutationId: String
  document: AkashaBeamStream!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type SetAkashaBlockStoragePayload {
  clientMutationId: String
  document: AkashaBlockStorage!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type SetAkashaContentBlockStreamPayload {
  clientMutationId: String
  document: AkashaContentBlockStream!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type SetAkashaFollowPayload {
  clientMutationId: String
  document: AkashaFollow!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type SetAkashaIndexedStreamPayload {
  clientMutationId: String
  document: AkashaIndexedStream!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type SetAkashaInterestsStreamPayload {
  clientMutationId: String
  document: AkashaInterestsStream!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type SetAkashaProfileInterestsPayload {
  clientMutationId: String
  document: AkashaProfileInterests!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type SetAkashaProfilePayload {
  clientMutationId: String
  document: AkashaProfile!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type SetAkashaProfileStreamPayload {
  clientMutationId: String
  document: AkashaProfileStream!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type SetAkashaReflectStreamPayload {
  clientMutationId: String
  document: AkashaReflectStream!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaAppPayload {
  clientMutationId: String
  document: AkashaApp!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaAppReleasePayload {
  clientMutationId: String
  document: AkashaAppRelease!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaAppsStreamPayload {
  clientMutationId: String
  document: AkashaAppsStream!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaBeamPayload {
  clientMutationId: String
  document: AkashaBeam!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaBeamStreamPayload {
  clientMutationId: String
  document: AkashaBeamStream!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaBlockStoragePayload {
  clientMutationId: String
  document: AkashaBlockStorage!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaContentBlockPayload {
  clientMutationId: String
  document: AkashaContentBlock!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaContentBlockStreamPayload {
  clientMutationId: String
  document: AkashaContentBlockStream!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaFollowPayload {
  clientMutationId: String
  document: AkashaFollow!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaIndexedStreamPayload {
  clientMutationId: String
  document: AkashaIndexedStream!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaInterestsStreamPayload {
  clientMutationId: String
  document: AkashaInterestsStream!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaProfileInterestsPayload {
  clientMutationId: String
  document: AkashaProfileInterests!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaProfilePayload {
  clientMutationId: String
  document: AkashaProfile!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaProfileStreamPayload {
  clientMutationId: String
  document: AkashaProfileStream!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaReflectPayload {
  clientMutationId: String
  document: AkashaReflect!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaReflectStreamPayload {
  clientMutationId: String
  document: AkashaReflectStream!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

enum AkashaAppApplicationType {
  APP
  OTHER
  PLUGIN
  WIDGET
}

enum AkashaAppsStreamModerationStatus {
  IN_REVIEW
  NSFW
  OK
  OTHER
  REMOVED
  SUSPENDED
}

enum AkashaBeamStreamModerationStatus {
  IN_REVIEW
  NSFW
  OK
  OTHER
  REMOVED
  SUSPENDED
}

enum AkashaBlockStorageBlockDef {
  ANIMATED_IMAGE
  BOOL
  EMOJI
  FORM
  FORM_DATA
  IMAGE
  OTHER
  RTF
  TEXT
  VIDEO
}

enum AkashaContentBlockBlockDef {
  ANIMATED_IMAGE
  BOOL
  EMOJI
  FORM
  FORM_DATA
  IMAGE
  OTHER
  RTF
  TEXT
  VIDEO
}

enum AkashaContentBlockStreamModerationStatus {
  IN_REVIEW
  NSFW
  OK
  OTHER
  REMOVED
  SUSPENDED
}

enum AkashaIndexedStreamModerationStatus {
  IN_REVIEW
  NSFW
  OK
  OTHER
  REMOVED
  SUSPENDED
}

enum AkashaIndexedStreamStreamType {
  APP
  BEAM
  EXTENSION
  OTHER
  PLUGIN
  PROFILE
  REFLECT
  WIDGET
}

enum AkashaInterestsStreamModerationStatus {
  IN_REVIEW
  NSFW
  OK
  OTHER
  REMOVED
  SUSPENDED
}

enum AkashaProfileStreamModerationStatus {
  IN_REVIEW
  NSFW
  OK
  OTHER
  REMOVED
  SUSPENDED
}

enum AkashaReflectStreamModerationStatus {
  IN_REVIEW
  NSFW
  OK
  OTHER
  REMOVED
  SUSPENDED
}

enum SortOrder {
  ASC
  DESC
}

"A Ceramic Commit ID"
scalar CeramicCommitID

"A Ceramic Stream ID"
scalar CeramicStreamID

"A field whose value conforms to the standard DID format as specified in did-core: https://www.w3.org/TR/did-core/."
scalar DID

"A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."
scalar DateTime

"A field whose value conforms to the standard Uniform Resource Identifier (URI) format as specified in RFC3986."
scalar URI

input AkashaAppApplicationTypeValueFilterInput {
  equalTo: AkashaAppApplicationType
  in: [AkashaAppApplicationType!]
  isNull: Boolean
  notEqualTo: AkashaAppApplicationType
  notIn: [AkashaAppApplicationType!]
}

input AkashaAppFiltersInput {
  and: [AkashaAppFiltersInput!]
  not: AkashaAppFiltersInput
  or: [AkashaAppFiltersInput!]
  where: AkashaAppObjectFilterInput
}

input AkashaAppInput {
  applicationType: AkashaAppApplicationType
  contributors: [DID]
  coverImage: AppImageSourceInput
  createdAt: DateTime!
  description: String!
  displayName: String!
  gallery: [AppImageSourceInput]
  keywords: [String]
  license: String!
  links: [AppLinkSourceInput]
  logoImage: AppImageSourceInput
  meta: [AppProviderValueInput]
  name: String!
  nsfw: Boolean
}

input AkashaAppInterfaceFiltersInput {
  and: [AkashaAppInterfaceFiltersInput!]
  not: AkashaAppInterfaceFiltersInput
  or: [AkashaAppInterfaceFiltersInput!]
  where: AkashaAppInterfaceObjectFilterInput
}

input AkashaAppInterfaceObjectFilterInput {
  createdAt: StringValueFilterInput
  description: StringValueFilterInput
  displayName: StringValueFilterInput
  license: StringValueFilterInput
  name: StringValueFilterInput
  nsfw: BooleanValueFilterInput
}

input AkashaAppInterfaceSortingInput {
  createdAt: SortOrder
  description: SortOrder
  displayName: SortOrder
  license: SortOrder
  name: SortOrder
  nsfw: SortOrder
}

input AkashaAppObjectFilterInput {
  applicationType: AkashaAppApplicationTypeValueFilterInput
  createdAt: StringValueFilterInput
  displayName: StringValueFilterInput
  name: StringValueFilterInput
}

input AkashaAppReleaseFiltersInput {
  and: [AkashaAppReleaseFiltersInput!]
  not: AkashaAppReleaseFiltersInput
  or: [AkashaAppReleaseFiltersInput!]
  where: AkashaAppReleaseObjectFilterInput
}

input AkashaAppReleaseInput {
  applicationID: CeramicStreamID!
  createdAt: DateTime!
  meta: [AppProviderValueInput]
  source: URI!
  version: String!
}

input AkashaAppReleaseInterfaceFiltersInput {
  and: [AkashaAppReleaseInterfaceFiltersInput!]
  not: AkashaAppReleaseInterfaceFiltersInput
  or: [AkashaAppReleaseInterfaceFiltersInput!]
  where: AkashaAppReleaseInterfaceObjectFilterInput
}

input AkashaAppReleaseInterfaceObjectFilterInput {
  applicationID: StringValueFilterInput
  createdAt: StringValueFilterInput
  source: StringValueFilterInput
  version: StringValueFilterInput
}

input AkashaAppReleaseInterfaceSortingInput {
  applicationID: SortOrder
  createdAt: SortOrder
  source: SortOrder
  version: SortOrder
}

input AkashaAppReleaseObjectFilterInput {
  applicationID: StringValueFilterInput
  createdAt: StringValueFilterInput
  version: StringValueFilterInput
}

input AkashaAppReleaseSortingInput {
  applicationID: SortOrder
  createdAt: SortOrder
  version: SortOrder
}

input AkashaAppSortingInput {
  applicationType: SortOrder
  createdAt: SortOrder
  displayName: SortOrder
  name: SortOrder
}

input AkashaAppsStreamFiltersInput {
  and: [AkashaAppsStreamFiltersInput!]
  not: AkashaAppsStreamFiltersInput
  or: [AkashaAppsStreamFiltersInput!]
  where: AkashaAppsStreamObjectFilterInput
}

input AkashaAppsStreamInput {
  active: Boolean!
  applicationID: CeramicStreamID!
  createdAt: DateTime!
  moderationID: CeramicStreamID
  status: AkashaAppsStreamModerationStatus
}

input AkashaAppsStreamModerationStatusValueFilterInput {
  equalTo: AkashaAppsStreamModerationStatus
  in: [AkashaAppsStreamModerationStatus!]
  isNull: Boolean
  notEqualTo: AkashaAppsStreamModerationStatus
  notIn: [AkashaAppsStreamModerationStatus!]
}

input AkashaAppsStreamObjectFilterInput {
  active: BooleanValueFilterInput
  applicationID: StringValueFilterInput
  createdAt: StringValueFilterInput
  moderationID: StringValueFilterInput
  status: AkashaAppsStreamModerationStatusValueFilterInput
}

input AkashaAppsStreamSortingInput {
  active: SortOrder
  applicationID: SortOrder
  createdAt: SortOrder
  moderationID: SortOrder
  status: SortOrder
}

input AkashaBeamFiltersInput {
  and: [AkashaBeamFiltersInput!]
  not: AkashaBeamFiltersInput
  or: [AkashaBeamFiltersInput!]
  where: AkashaBeamObjectFilterInput
}

input AkashaBeamInput {
  active: Boolean!
  appID: CeramicStreamID!
  appVersionID: CeramicStreamID!
  content: [BeamBlockRecordInput]!
  createdAt: DateTime!
  embeddedStream: BeamEmbeddedTypeInput
  mentions: [DID]
  nsfw: Boolean
  tags: [BeamLabeledInput]
}

input AkashaBeamInterfaceFiltersInput {
  and: [AkashaBeamInterfaceFiltersInput!]
  not: AkashaBeamInterfaceFiltersInput
  or: [AkashaBeamInterfaceFiltersInput!]
  where: AkashaBeamInterfaceObjectFilterInput
}

input AkashaBeamInterfaceObjectFilterInput {
  active: BooleanValueFilterInput
  appID: StringValueFilterInput
  appVersionID: StringValueFilterInput
  createdAt: StringValueFilterInput
  nsfw: BooleanValueFilterInput
}

input AkashaBeamInterfaceSortingInput {
  active: SortOrder
  appID: SortOrder
  appVersionID: SortOrder
  createdAt: SortOrder
  nsfw: SortOrder
}

input AkashaBeamObjectFilterInput {
  active: BooleanValueFilterInput
  createdAt: StringValueFilterInput
  nsfw: BooleanValueFilterInput
}

input AkashaBeamSortingInput {
  active: SortOrder
  createdAt: SortOrder
  nsfw: SortOrder
}

input AkashaBeamStreamFiltersInput {
  and: [AkashaBeamStreamFiltersInput!]
  not: AkashaBeamStreamFiltersInput
  or: [AkashaBeamStreamFiltersInput!]
  where: AkashaBeamStreamObjectFilterInput
}

input AkashaBeamStreamInput {
  active: Boolean!
  appID: CeramicStreamID
  beamID: CeramicStreamID!
  createdAt: DateTime!
  moderationID: CeramicStreamID
  status: AkashaBeamStreamModerationStatus
}

input AkashaBeamStreamModerationStatusValueFilterInput {
  equalTo: AkashaBeamStreamModerationStatus
  in: [AkashaBeamStreamModerationStatus!]
  isNull: Boolean
  notEqualTo: AkashaBeamStreamModerationStatus
  notIn: [AkashaBeamStreamModerationStatus!]
}

input AkashaBeamStreamObjectFilterInput {
  active: BooleanValueFilterInput
  beamID: StringValueFilterInput
  createdAt: StringValueFilterInput
  moderationID: StringValueFilterInput
  status: AkashaBeamStreamModerationStatusValueFilterInput
}

input AkashaBeamStreamSortingInput {
  active: SortOrder
  beamID: SortOrder
  createdAt: SortOrder
  moderationID: SortOrder
  status: SortOrder
}

input AkashaBlockStorageBlockDefValueFilterInput {
  equalTo: AkashaBlockStorageBlockDef
  in: [AkashaBlockStorageBlockDef!]
  isNull: Boolean
  notEqualTo: AkashaBlockStorageBlockDef
  notIn: [AkashaBlockStorageBlockDef!]
}

input AkashaBlockStorageFiltersInput {
  and: [AkashaBlockStorageFiltersInput!]
  not: AkashaBlockStorageFiltersInput
  or: [AkashaBlockStorageFiltersInput!]
  where: AkashaBlockStorageObjectFilterInput
}

input AkashaBlockStorageInput {
  active: Boolean!
  appVersionID: CeramicStreamID!
  blockID: CeramicStreamID!
  content: [BlockLabeledValueInput]!
  createdAt: DateTime!
  kind: AkashaBlockStorageBlockDef
  nsfw: Boolean
}

input AkashaBlockStorageObjectFilterInput {
  active: BooleanValueFilterInput
  appVersionID: StringValueFilterInput
  blockID: StringValueFilterInput
  createdAt: StringValueFilterInput
  kind: AkashaBlockStorageBlockDefValueFilterInput
  nsfw: BooleanValueFilterInput
}

input AkashaBlockStorageSortingInput {
  active: SortOrder
  appVersionID: SortOrder
  blockID: SortOrder
  createdAt: SortOrder
  kind: SortOrder
  nsfw: SortOrder
}

input AkashaContentBlockBlockDefValueFilterInput {
  equalTo: AkashaContentBlockBlockDef
  in: [AkashaContentBlockBlockDef!]
  isNull: Boolean
  notEqualTo: AkashaContentBlockBlockDef
  notIn: [AkashaContentBlockBlockDef!]
}

input AkashaContentBlockFiltersInput {
  and: [AkashaContentBlockFiltersInput!]
  not: AkashaContentBlockFiltersInput
  or: [AkashaContentBlockFiltersInput!]
  where: AkashaContentBlockObjectFilterInput
}

input AkashaContentBlockInput {
  active: Boolean!
  appVersionID: CeramicStreamID!
  content: [BlockLabeledValueInput]!
  createdAt: DateTime!
  kind: AkashaContentBlockBlockDef
  nsfw: Boolean
}

input AkashaContentBlockInterfaceFiltersInput {
  and: [AkashaContentBlockInterfaceFiltersInput!]
  not: AkashaContentBlockInterfaceFiltersInput
  or: [AkashaContentBlockInterfaceFiltersInput!]
  where: AkashaContentBlockInterfaceObjectFilterInput
}

input AkashaContentBlockInterfaceObjectFilterInput {
  active: BooleanValueFilterInput
  appVersionID: StringValueFilterInput
  createdAt: StringValueFilterInput
  nsfw: BooleanValueFilterInput
}

input AkashaContentBlockInterfaceSortingInput {
  active: SortOrder
  appVersionID: SortOrder
  createdAt: SortOrder
  nsfw: SortOrder
}

input AkashaContentBlockObjectFilterInput {
  active: BooleanValueFilterInput
  appVersionID: StringValueFilterInput
  createdAt: StringValueFilterInput
  kind: AkashaContentBlockBlockDefValueFilterInput
  nsfw: BooleanValueFilterInput
}

input AkashaContentBlockSortingInput {
  active: SortOrder
  appVersionID: SortOrder
  createdAt: SortOrder
  kind: SortOrder
  nsfw: SortOrder
}

input AkashaContentBlockStreamFiltersInput {
  and: [AkashaContentBlockStreamFiltersInput!]
  not: AkashaContentBlockStreamFiltersInput
  or: [AkashaContentBlockStreamFiltersInput!]
  where: AkashaContentBlockStreamObjectFilterInput
}

input AkashaContentBlockStreamInput {
  active: Boolean!
  blockID: CeramicStreamID!
  createdAt: DateTime!
  moderationID: CeramicStreamID
  status: AkashaContentBlockStreamModerationStatus
}

input AkashaContentBlockStreamModerationStatusValueFilterInput {
  equalTo: AkashaContentBlockStreamModerationStatus
  in: [AkashaContentBlockStreamModerationStatus!]
  isNull: Boolean
  notEqualTo: AkashaContentBlockStreamModerationStatus
  notIn: [AkashaContentBlockStreamModerationStatus!]
}

input AkashaContentBlockStreamObjectFilterInput {
  active: BooleanValueFilterInput
  blockID: StringValueFilterInput
  createdAt: StringValueFilterInput
  moderationID: StringValueFilterInput
  status: AkashaContentBlockStreamModerationStatusValueFilterInput
}

input AkashaContentBlockStreamSortingInput {
  active: SortOrder
  blockID: SortOrder
  createdAt: SortOrder
  moderationID: SortOrder
  status: SortOrder
}

input AkashaFollowFiltersInput {
  and: [AkashaFollowFiltersInput!]
  not: AkashaFollowFiltersInput
  or: [AkashaFollowFiltersInput!]
  where: AkashaFollowObjectFilterInput
}

input AkashaFollowInput {
  isFollowing: Boolean!
  profileID: CeramicStreamID!
}

input AkashaFollowInterfaceFiltersInput {
  and: [AkashaFollowInterfaceFiltersInput!]
  not: AkashaFollowInterfaceFiltersInput
  or: [AkashaFollowInterfaceFiltersInput!]
  where: AkashaFollowInterfaceObjectFilterInput
}

input AkashaFollowInterfaceObjectFilterInput {
  isFollowing: BooleanValueFilterInput
  profileID: StringValueFilterInput
}

input AkashaFollowInterfaceSortingInput {
  isFollowing: SortOrder
  profileID: SortOrder
}

input AkashaFollowObjectFilterInput {
  isFollowing: BooleanValueFilterInput
  profileID: StringValueFilterInput
}

input AkashaFollowSortingInput {
  isFollowing: SortOrder
  profileID: SortOrder
}

input AkashaIndexStreamInterfaceFiltersInput {
  and: [AkashaIndexStreamInterfaceFiltersInput!]
  not: AkashaIndexStreamInterfaceFiltersInput
  or: [AkashaIndexStreamInterfaceFiltersInput!]
  where: AkashaIndexStreamInterfaceObjectFilterInput
}

input AkashaIndexStreamInterfaceObjectFilterInput {
  active: BooleanValueFilterInput
  createdAt: StringValueFilterInput
  moderationID: StringValueFilterInput
}

input AkashaIndexStreamInterfaceSortingInput {
  active: SortOrder
  createdAt: SortOrder
  moderationID: SortOrder
}

input AkashaIndexedStreamFiltersInput {
  and: [AkashaIndexedStreamFiltersInput!]
  not: AkashaIndexedStreamFiltersInput
  or: [AkashaIndexedStreamFiltersInput!]
  where: AkashaIndexedStreamObjectFilterInput
}

input AkashaIndexedStreamInput {
  active: Boolean!
  createdAt: DateTime!
  indexType: String!
  indexValue: String!
  moderationID: CeramicStreamID
  status: AkashaIndexedStreamModerationStatus
  stream: CeramicStreamID!
  streamType: AkashaIndexedStreamStreamType
}

input AkashaIndexedStreamModerationStatusValueFilterInput {
  equalTo: AkashaIndexedStreamModerationStatus
  in: [AkashaIndexedStreamModerationStatus!]
  isNull: Boolean
  notEqualTo: AkashaIndexedStreamModerationStatus
  notIn: [AkashaIndexedStreamModerationStatus!]
}

input AkashaIndexedStreamObjectFilterInput {
  active: BooleanValueFilterInput
  createdAt: StringValueFilterInput
  indexType: StringValueFilterInput
  indexValue: StringValueFilterInput
  moderationID: StringValueFilterInput
  status: AkashaIndexedStreamModerationStatusValueFilterInput
  stream: StringValueFilterInput
  streamType: AkashaIndexedStreamStreamTypeValueFilterInput
}

input AkashaIndexedStreamSortingInput {
  active: SortOrder
  createdAt: SortOrder
  indexType: SortOrder
  indexValue: SortOrder
  moderationID: SortOrder
  status: SortOrder
  stream: SortOrder
  streamType: SortOrder
}

input AkashaIndexedStreamStreamTypeValueFilterInput {
  equalTo: AkashaIndexedStreamStreamType
  in: [AkashaIndexedStreamStreamType!]
  isNull: Boolean
  notEqualTo: AkashaIndexedStreamStreamType
  notIn: [AkashaIndexedStreamStreamType!]
}

input AkashaInterestsStreamFiltersInput {
  and: [AkashaInterestsStreamFiltersInput!]
  not: AkashaInterestsStreamFiltersInput
  or: [AkashaInterestsStreamFiltersInput!]
  where: AkashaInterestsStreamObjectFilterInput
}

input AkashaInterestsStreamInput {
  active: Boolean!
  createdAt: DateTime!
  labelType: String!
  moderationID: CeramicStreamID
  status: AkashaInterestsStreamModerationStatus
  value: String!
}

input AkashaInterestsStreamModerationStatusValueFilterInput {
  equalTo: AkashaInterestsStreamModerationStatus
  in: [AkashaInterestsStreamModerationStatus!]
  isNull: Boolean
  notEqualTo: AkashaInterestsStreamModerationStatus
  notIn: [AkashaInterestsStreamModerationStatus!]
}

input AkashaInterestsStreamObjectFilterInput {
  active: BooleanValueFilterInput
  createdAt: StringValueFilterInput
  labelType: StringValueFilterInput
  moderationID: StringValueFilterInput
  status: AkashaInterestsStreamModerationStatusValueFilterInput
  value: StringValueFilterInput
}

input AkashaInterestsStreamSortingInput {
  active: SortOrder
  createdAt: SortOrder
  labelType: SortOrder
  moderationID: SortOrder
  status: SortOrder
  value: SortOrder
}

input AkashaProfileFiltersInput {
  and: [AkashaProfileFiltersInput!]
  not: AkashaProfileFiltersInput
  or: [AkashaProfileFiltersInput!]
  where: AkashaProfileObjectFilterInput
}

input AkashaProfileInput {
  appID: CeramicStreamID!
  appVersionID: CeramicStreamID!
  avatar: ProfileImageVersionsInput
  background: ProfileImageVersionsInput
  createdAt: DateTime!
  description: String
  links: [ProfileLinkSourceInput]
  name: String!
  nsfw: Boolean
}

input AkashaProfileInterestsInput {
  topics: [ProfileLabeledInput]!
}

input AkashaProfileInterfaceFiltersInput {
  and: [AkashaProfileInterfaceFiltersInput!]
  not: AkashaProfileInterfaceFiltersInput
  or: [AkashaProfileInterfaceFiltersInput!]
  where: AkashaProfileInterfaceObjectFilterInput
}

input AkashaProfileInterfaceObjectFilterInput {
  appID: StringValueFilterInput
  appVersionID: StringValueFilterInput
  createdAt: StringValueFilterInput
  description: StringValueFilterInput
  name: StringValueFilterInput
  nsfw: BooleanValueFilterInput
}

input AkashaProfileInterfaceSortingInput {
  appID: SortOrder
  appVersionID: SortOrder
  createdAt: SortOrder
  description: SortOrder
  name: SortOrder
  nsfw: SortOrder
}

input AkashaProfileObjectFilterInput {
  createdAt: StringValueFilterInput
  name: StringValueFilterInput
  nsfw: BooleanValueFilterInput
}

input AkashaProfileSortingInput {
  createdAt: SortOrder
  name: SortOrder
  nsfw: SortOrder
}

input AkashaProfileStreamFiltersInput {
  and: [AkashaProfileStreamFiltersInput!]
  not: AkashaProfileStreamFiltersInput
  or: [AkashaProfileStreamFiltersInput!]
  where: AkashaProfileStreamObjectFilterInput
}

input AkashaProfileStreamInput {
  active: Boolean!
  appID: CeramicStreamID
  createdAt: DateTime!
  moderationID: CeramicStreamID
  profileID: CeramicStreamID!
  status: AkashaProfileStreamModerationStatus
}

input AkashaProfileStreamModerationStatusValueFilterInput {
  equalTo: AkashaProfileStreamModerationStatus
  in: [AkashaProfileStreamModerationStatus!]
  isNull: Boolean
  notEqualTo: AkashaProfileStreamModerationStatus
  notIn: [AkashaProfileStreamModerationStatus!]
}

input AkashaProfileStreamObjectFilterInput {
  active: BooleanValueFilterInput
  createdAt: StringValueFilterInput
  moderationID: StringValueFilterInput
  profileID: StringValueFilterInput
  status: AkashaProfileStreamModerationStatusValueFilterInput
}

input AkashaProfileStreamSortingInput {
  active: SortOrder
  createdAt: SortOrder
  moderationID: SortOrder
  profileID: SortOrder
  status: SortOrder
}

input AkashaReflectFiltersInput {
  and: [AkashaReflectFiltersInput!]
  not: AkashaReflectFiltersInput
  or: [AkashaReflectFiltersInput!]
  where: AkashaReflectObjectFilterInput
}

input AkashaReflectInput {
  active: Boolean!
  beamID: CeramicStreamID!
  content: [ReflectProviderValueInput]!
  createdAt: DateTime!
  isReply: Boolean
  mentions: [CeramicStreamID]
  nsfw: Boolean
  reflection: CeramicStreamID
  tags: [String]
}

input AkashaReflectInterfaceFiltersInput {
  and: [AkashaReflectInterfaceFiltersInput!]
  not: AkashaReflectInterfaceFiltersInput
  or: [AkashaReflectInterfaceFiltersInput!]
  where: AkashaReflectInterfaceObjectFilterInput
}

input AkashaReflectInterfaceObjectFilterInput {
  active: BooleanValueFilterInput
  beamID: StringValueFilterInput
  createdAt: StringValueFilterInput
  isReply: BooleanValueFilterInput
  nsfw: BooleanValueFilterInput
  reflection: StringValueFilterInput
}

input AkashaReflectInterfaceSortingInput {
  active: SortOrder
  beamID: SortOrder
  createdAt: SortOrder
  isReply: SortOrder
  nsfw: SortOrder
  reflection: SortOrder
}

input AkashaReflectObjectFilterInput {
  active: BooleanValueFilterInput
  beamID: StringValueFilterInput
  createdAt: StringValueFilterInput
  isReply: BooleanValueFilterInput
  nsfw: BooleanValueFilterInput
  reflection: StringValueFilterInput
}

input AkashaReflectSortingInput {
  active: SortOrder
  beamID: SortOrder
  createdAt: SortOrder
  isReply: SortOrder
  nsfw: SortOrder
  reflection: SortOrder
}

input AkashaReflectStreamFiltersInput {
  and: [AkashaReflectStreamFiltersInput!]
  not: AkashaReflectStreamFiltersInput
  or: [AkashaReflectStreamFiltersInput!]
  where: AkashaReflectStreamObjectFilterInput
}

input AkashaReflectStreamInput {
  active: Boolean!
  beamID: CeramicStreamID!
  createdAt: DateTime!
  isReply: Boolean
  moderationID: CeramicStreamID
  reflectionID: CeramicStreamID!
  replyTo: CeramicStreamID
  status: AkashaReflectStreamModerationStatus
}

input AkashaReflectStreamModerationStatusValueFilterInput {
  equalTo: AkashaReflectStreamModerationStatus
  in: [AkashaReflectStreamModerationStatus!]
  isNull: Boolean
  notEqualTo: AkashaReflectStreamModerationStatus
  notIn: [AkashaReflectStreamModerationStatus!]
}

input AkashaReflectStreamObjectFilterInput {
  active: BooleanValueFilterInput
  beamID: StringValueFilterInput
  createdAt: StringValueFilterInput
  isReply: BooleanValueFilterInput
  moderationID: StringValueFilterInput
  reflectionID: StringValueFilterInput
  replyTo: StringValueFilterInput
  status: AkashaReflectStreamModerationStatusValueFilterInput
}

input AkashaReflectStreamSortingInput {
  active: SortOrder
  beamID: SortOrder
  createdAt: SortOrder
  isReply: SortOrder
  moderationID: SortOrder
  reflectionID: SortOrder
  replyTo: SortOrder
  status: SortOrder
}

input AppImageSourceInput {
  height: Int
  src: URI!
  width: Int
}

input AppLinkSourceInput {
  href: URI!
  label: String
}

input AppProviderValueInput {
  property: String!
  provider: String!
  value: String!
}

input BeamBlockRecordInput {
  blockID: CeramicStreamID!
  order: Int!
}

input BeamEmbeddedTypeInput {
  embeddedID: CeramicStreamID!
  label: String!
}

input BeamLabeledInput {
  labelType: String!
  value: String!
}

input BlockLabeledValueInput {
  label: String!
  propertyType: String!
  value: String!
}

input BooleanValueFilterInput {
  equalTo: Boolean
  isNull: Boolean
}

input CreateAkashaBeamInput {
  clientMutationId: String
  content: AkashaBeamInput!
  options: CreateOptionsInput
}

input CreateAkashaContentBlockInput {
  clientMutationId: String
  content: AkashaContentBlockInput!
  options: CreateOptionsInput
}

input CreateAkashaProfileInput {
  clientMutationId: String
  content: AkashaProfileInput!
  options: SetOptionsInput
}

input CreateAkashaProfileInterestsInput {
  clientMutationId: String
  content: AkashaProfileInterestsInput!
  options: SetOptionsInput
}

input CreateAkashaReflectInput {
  clientMutationId: String
  content: AkashaReflectInput!
  options: CreateOptionsInput
}

input CreateOptionsInput {
  "Inform indexers if they should index this document or not"
  shouldIndex: Boolean
}

input EnableIndexingAkashaAppInput {
  clientMutationId: String
  id: ID!
  shouldIndex: Boolean!
}

input EnableIndexingAkashaAppReleaseInput {
  clientMutationId: String
  id: ID!
  shouldIndex: Boolean!
}

input EnableIndexingAkashaAppsStreamInput {
  clientMutationId: String
  id: ID!
  shouldIndex: Boolean!
}

input EnableIndexingAkashaBeamInput {
  clientMutationId: String
  id: ID!
  shouldIndex: Boolean!
}

input EnableIndexingAkashaBeamStreamInput {
  clientMutationId: String
  id: ID!
  shouldIndex: Boolean!
}

input EnableIndexingAkashaBlockStorageInput {
  clientMutationId: String
  id: ID!
  shouldIndex: Boolean!
}

input EnableIndexingAkashaContentBlockInput {
  clientMutationId: String
  id: ID!
  shouldIndex: Boolean!
}

input EnableIndexingAkashaContentBlockStreamInput {
  clientMutationId: String
  id: ID!
  shouldIndex: Boolean!
}

input EnableIndexingAkashaFollowInput {
  clientMutationId: String
  id: ID!
  shouldIndex: Boolean!
}

input EnableIndexingAkashaIndexedStreamInput {
  clientMutationId: String
  id: ID!
  shouldIndex: Boolean!
}

input EnableIndexingAkashaInterestsStreamInput {
  clientMutationId: String
  id: ID!
  shouldIndex: Boolean!
}

input EnableIndexingAkashaProfileInput {
  clientMutationId: String
  id: ID!
  shouldIndex: Boolean!
}

input EnableIndexingAkashaProfileInterestsInput {
  clientMutationId: String
  id: ID!
  shouldIndex: Boolean!
}

input EnableIndexingAkashaProfileStreamInput {
  clientMutationId: String
  id: ID!
  shouldIndex: Boolean!
}

input EnableIndexingAkashaReflectInput {
  clientMutationId: String
  id: ID!
  shouldIndex: Boolean!
}

input EnableIndexingAkashaReflectStreamInput {
  clientMutationId: String
  id: ID!
  shouldIndex: Boolean!
}

input PartialAkashaAppInput {
  applicationType: AkashaAppApplicationType
  contributors: [DID]
  coverImage: AppImageSourceInput
  description: String
  gallery: [AppImageSourceInput]
  links: [AppLinkSourceInput]
  logoImage: AppImageSourceInput
  meta: [AppProviderValueInput]
}

input PartialAkashaAppReleaseInput {
  meta: [AppProviderValueInput]
}

input PartialAkashaAppsStreamInput {
  active: Boolean
  status: AkashaAppsStreamModerationStatus
}

input PartialAkashaBeamInput {
  active: Boolean
  nsfw: Boolean
}

input PartialAkashaBeamStreamInput {
  active: Boolean
  status: AkashaBeamStreamModerationStatus
}

input PartialAkashaBlockStorageInput {
  active: Boolean
  kind: AkashaBlockStorageBlockDef
}

input PartialAkashaContentBlockInput {
  active: Boolean
  kind: AkashaContentBlockBlockDef
}

input PartialAkashaContentBlockStreamInput {
  active: Boolean
  status: AkashaContentBlockStreamModerationStatus
}

input PartialAkashaFollowInput {
  isFollowing: Boolean
}

input PartialAkashaIndexedStreamInput {
  active: Boolean
  status: AkashaIndexedStreamModerationStatus
  streamType: AkashaIndexedStreamStreamType
}

input PartialAkashaInterestsStreamInput {
  active: Boolean
  status: AkashaInterestsStreamModerationStatus
}

input PartialAkashaProfileInput {
  avatar: ProfileImageVersionsInput
  background: ProfileImageVersionsInput
  description: String
  links: [ProfileLinkSourceInput]
  name: String
}

input PartialAkashaProfileInterestsInput {
  topics: [ProfileLabeledInput]
}

input PartialAkashaProfileStreamInput {
  active: Boolean
  status: AkashaProfileStreamModerationStatus
}

input PartialAkashaReflectInput {
  active: Boolean
  nsfw: Boolean
}

input PartialAkashaReflectStreamInput {
  active: Boolean
  beamID: CeramicStreamID
  isReply: Boolean
  replyTo: CeramicStreamID
  status: AkashaReflectStreamModerationStatus
}

input ProfileImageSourceInput {
  height: Int!
  src: URI!
  width: Int!
}

input ProfileImageVersionsInput {
  alternatives: [ProfileImageSourceInput]
  default: ProfileImageSourceInput!
}

input ProfileLabeledInput {
  labelType: String!
  value: String!
}

input ProfileLinkSourceInput {
  href: URI!
  label: String
}

input ReflectProviderValueInput {
  label: String!
  propertyType: String!
  value: String!
}

input SetAkashaAppInput {
  clientMutationId: String
  content: AkashaAppInput!
  options: SetOptionsInput
}

input SetAkashaAppReleaseInput {
  clientMutationId: String
  content: AkashaAppReleaseInput!
  options: SetOptionsInput
}

input SetAkashaAppsStreamInput {
  clientMutationId: String
  content: AkashaAppsStreamInput!
  options: SetOptionsInput
}

input SetAkashaBeamStreamInput {
  clientMutationId: String
  content: AkashaBeamStreamInput!
  options: SetOptionsInput
}

input SetAkashaBlockStorageInput {
  clientMutationId: String
  content: AkashaBlockStorageInput!
  options: SetOptionsInput
}

input SetAkashaContentBlockStreamInput {
  clientMutationId: String
  content: AkashaContentBlockStreamInput!
  options: SetOptionsInput
}

input SetAkashaFollowInput {
  clientMutationId: String
  content: AkashaFollowInput!
  options: SetOptionsInput
}

input SetAkashaIndexedStreamInput {
  clientMutationId: String
  content: AkashaIndexedStreamInput!
  options: SetOptionsInput
}

input SetAkashaInterestsStreamInput {
  clientMutationId: String
  content: AkashaInterestsStreamInput!
  options: SetOptionsInput
}

input SetAkashaProfileInput {
  clientMutationId: String
  content: AkashaProfileInput!
  options: SetOptionsInput
}

input SetAkashaProfileInterestsInput {
  clientMutationId: String
  content: AkashaProfileInterestsInput!
  options: SetOptionsInput
}

input SetAkashaProfileStreamInput {
  clientMutationId: String
  content: AkashaProfileStreamInput!
  options: SetOptionsInput
}

input SetAkashaReflectStreamInput {
  clientMutationId: String
  content: AkashaReflectStreamInput!
  options: SetOptionsInput
}

input SetOptionsInput {
  "Inform indexers if they should index this document or not"
  shouldIndex: Boolean
  "Maximum amount of time to lookup the stream over the network, in seconds - see https://developers.ceramic.network/reference/typescript/interfaces/_ceramicnetwork_common.CreateOpts.html#syncTimeoutSeconds"
  syncTimeout: Int
}

input StringValueFilterInput {
  equalTo: String
  greaterThan: String
  greaterThanOrEqualTo: String
  in: [String!]
  isNull: Boolean
  lessThan: String
  lessThanOrEqualTo: String
  notEqualTo: String
  notIn: [String!]
}

input UpdateAkashaAppInput {
  clientMutationId: String
  content: PartialAkashaAppInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaAppReleaseInput {
  clientMutationId: String
  content: PartialAkashaAppReleaseInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaAppsStreamInput {
  clientMutationId: String
  content: PartialAkashaAppsStreamInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaBeamInput {
  clientMutationId: String
  content: PartialAkashaBeamInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaBeamStreamInput {
  clientMutationId: String
  content: PartialAkashaBeamStreamInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaBlockStorageInput {
  clientMutationId: String
  content: PartialAkashaBlockStorageInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaContentBlockInput {
  clientMutationId: String
  content: PartialAkashaContentBlockInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaContentBlockStreamInput {
  clientMutationId: String
  content: PartialAkashaContentBlockStreamInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaFollowInput {
  clientMutationId: String
  content: PartialAkashaFollowInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaIndexedStreamInput {
  clientMutationId: String
  content: PartialAkashaIndexedStreamInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaInterestsStreamInput {
  clientMutationId: String
  content: PartialAkashaInterestsStreamInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaProfileInput {
  clientMutationId: String
  content: PartialAkashaProfileInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaProfileInterestsInput {
  clientMutationId: String
  content: PartialAkashaProfileInterestsInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaProfileStreamInput {
  clientMutationId: String
  content: PartialAkashaProfileStreamInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaReflectInput {
  clientMutationId: String
  content: PartialAkashaReflectInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaReflectStreamInput {
  clientMutationId: String
  content: PartialAkashaReflectStreamInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateOptionsInput {
  "Fully replace the document contents instead of performing a shallow merge"
  replace: Boolean = false
  "Inform indexers if they should index this document or not"
  shouldIndex: Boolean
  "Only perform mutation if the document matches the provided version"
  version: CeramicCommitID
}

input WithAkashaAppInput {
  name: String!
}

input WithAkashaAppReleaseInput {
  applicationID: CeramicStreamID!
  version: String!
}

input WithAkashaAppsStreamInput {
  applicationID: CeramicStreamID!
}

input WithAkashaBeamStreamInput {
  beamID: CeramicStreamID!
}

input WithAkashaBlockStorageInput {
  blockID: CeramicStreamID!
}

input WithAkashaContentBlockStreamInput {
  blockID: CeramicStreamID!
}

input WithAkashaFollowInput {
  profileID: CeramicStreamID!
}

input WithAkashaIndexedStreamInput {
  indexType: String!
  indexValue: String!
  stream: CeramicStreamID!
}

input WithAkashaInterestsStreamInput {
  labelType: String!
  value: String!
}

input WithAkashaProfileStreamInput {
  profileID: CeramicStreamID!
}

input WithAkashaReflectStreamInput {
  reflectionID: CeramicStreamID!
}
