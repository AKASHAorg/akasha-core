# This file was generated. Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"An object with an ID"
interface Node {
    "The id of the object."
    id: ID!
}

type AkashaApp implements Node {
    applicationType: AkashaAppApplicationType
    "Account controlling the document"
    author: CeramicAccount!
    contributors: [CeramicAccount]
    createdAt: DateTime!
    description: String!
    displayName: String!
    id: ID!
    keywords: [String]
    licence: String!
    name: String!
    releases(
        "Returns only documents created by the provided account"
        account: ID,
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaAppReleaseFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaAppReleaseSortingInput
    ): AkashaAppReleaseConnection!
    releasesCount(
        "Counts only documents created by the provided account"
        account: ID,
        filters: AkashaAppReleaseFiltersInput
    ): Int!
    "Current version of the document"
    version: CeramicCommitID!
}

"A connection to a list of items."
type AkashaAppConnection {
    "A list of edges."
    edges: [AkashaAppEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaAppEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: AkashaApp
}

type AkashaAppRelease implements Node {
    application: AkashaApp
    applicationID: CeramicStreamID!
    createdAt: DateTime!
    id: ID!
    source: InterPlanetaryCID!
    version: String!
}

"A connection to a list of items."
type AkashaAppReleaseConnection {
    "A list of edges."
    edges: [AkashaAppReleaseEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaAppReleaseEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: AkashaAppRelease
}

type AkashaAppsStream implements Node {
    active: Boolean!
    application: AkashaApp
    applicationID: CeramicStreamID!
    createdAt: DateTime!
    id: ID!
    moderationID: CeramicStreamID
    status: AkashaAppsStreamModerationStatus
}

"A connection to a list of items."
type AkashaAppsStreamConnection {
    "A list of edges."
    edges: [AkashaAppsStreamEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaAppsStreamEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: AkashaAppsStream
}

type AkashaBeam implements Node {
    active: Boolean!
    "Account controlling the document"
    author: CeramicAccount!
    content: [AkashaBeamBlockRecord!]!
    createdAt: DateTime!
    embeddedStream: AkashaBeamEmbeddedType
    id: ID!
    mentions: [CeramicAccount]
    nsfw: Boolean
    reflections(
        "Returns only documents created by the provided account"
        account: ID,
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaReflectFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaReflectSortingInput
    ): AkashaReflectConnection!
    reflectionsCount(
        "Counts only documents created by the provided account"
        account: ID,
        filters: AkashaReflectFiltersInput
    ): Int!
    tags: [AkashaBeamLabeled]
    "Current version of the document"
    version: CeramicCommitID!
}

type AkashaBeamBlockRecord {
    blockID: CeramicStreamID!
    order: Int!
}

"A connection to a list of items."
type AkashaBeamConnection {
    "A list of edges."
    edges: [AkashaBeamEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaBeamEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: AkashaBeam
}

type AkashaBeamEmbeddedType {
    embeddedID: CeramicStreamID!
    label: String!
}

type AkashaBeamLabeled {
    labelType: String!
    value: String!
}

type AkashaBeamStream implements Node {
    active: Boolean!
    beam: AkashaBeam
    beamID: CeramicStreamID!
    createdAt: DateTime!
    id: ID!
    moderationID: CeramicStreamID
    status: AkashaBeamStreamModerationStatus
}

"A connection to a list of items."
type AkashaBeamStreamConnection {
    "A list of edges."
    edges: [AkashaBeamStreamEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaBeamStreamEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: AkashaBeamStream
}

type AkashaBlockStorage implements Node {
    active: Boolean!
    appVersion: AkashaAppRelease
    appVersionID: CeramicStreamID!
    "Account controlling the document"
    author: CeramicAccount!
    block: AkashaContentBlock
    blockID: CeramicStreamID!
    content: [AkashaBlockStorageLabeledValue!]!
    createdAt: DateTime!
    id: ID!
    kind: AkashaBlockStorageBlockStorageDef
    "Current version of the document"
    version: CeramicCommitID!
}

"A connection to a list of items."
type AkashaBlockStorageConnection {
    "A list of edges."
    edges: [AkashaBlockStorageEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaBlockStorageEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: AkashaBlockStorage
}

type AkashaBlockStorageLabeledValue {
    label: String!
    propertyType: String!
    value: String!
}

type AkashaContentBlock implements Node {
    active: Boolean!
    appVersion: AkashaAppRelease
    appVersionID: CeramicStreamID!
    "Account controlling the document"
    author: CeramicAccount!
    content: [AkashaContentBlockLabeledValue!]!
    createdAt: DateTime!
    id: ID!
    kind: AkashaContentBlockBlockDef
    nsfw: Boolean
    "Current version of the document"
    version: CeramicCommitID!
}

"A connection to a list of items."
type AkashaContentBlockConnection {
    "A list of edges."
    edges: [AkashaContentBlockEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaContentBlockEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: AkashaContentBlock
}

type AkashaContentBlockLabeledValue {
    label: String!
    propertyType: String!
    value: String!
}

type AkashaContentBlockStream implements Node {
    active: Boolean!
    block: AkashaContentBlock
    blockID: CeramicStreamID!
    createdAt: DateTime!
    id: ID!
    moderationID: CeramicStreamID
    status: AkashaContentBlockStreamModerationStatus
}

"A connection to a list of items."
type AkashaContentBlockStreamConnection {
    "A list of edges."
    edges: [AkashaContentBlockStreamEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaContentBlockStreamEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: AkashaContentBlockStream
}

type AkashaFollow implements Node {
    "Account controlling the document"
    did: CeramicAccount!
    id: ID!
    isFollowing: Boolean!
    profile: AkashaProfile
    profileID: CeramicStreamID!
}

"A connection to a list of items."
type AkashaFollowConnection {
    "A list of edges."
    edges: [AkashaFollowEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaFollowEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: AkashaFollow
}

type AkashaIndexedStream implements Node {
    active: Boolean!
    createdAt: DateTime!
    id: ID!
    indexType: String!
    indexValue: String!
    moderationID: CeramicStreamID
    status: AkashaIndexedStreamModerationStatus
    stream: CeramicStreamID!
    streamType: AkashaIndexedStreamStreamType
}

"A connection to a list of items."
type AkashaIndexedStreamConnection {
    "A list of edges."
    edges: [AkashaIndexedStreamEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaIndexedStreamEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: AkashaIndexedStream
}

type AkashaInterestsStream implements Node {
    active: Boolean!
    createdAt: DateTime!
    id: ID!
    labelType: String!
    moderationID: CeramicStreamID
    status: AkashaInterestsStreamModerationStatus
    value: String!
}

"A connection to a list of items."
type AkashaInterestsStreamConnection {
    "A list of edges."
    edges: [AkashaInterestsStreamEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaInterestsStreamEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: AkashaInterestsStream
}

type AkashaProfile implements Node {
    avatar: AkashaProfileImageVersions
    background: AkashaProfileImageVersions
    createdAt: DateTime!
    description: String
    "Account controlling the document"
    did: CeramicAccount!
    followers(
        "Returns only documents created by the provided account"
        account: ID,
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaFollowFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaFollowSortingInput
    ): AkashaFollowConnection!
    followersCount(
        "Counts only documents created by the provided account"
        account: ID,
        filters: AkashaFollowFiltersInput
    ): Int!
    id: ID!
    links: [AkashaProfileLinkSource]
    name: String!
    nsfw: Boolean
}

"A connection to a list of items."
type AkashaProfileConnection {
    "A list of edges."
    edges: [AkashaProfileEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaProfileEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: AkashaProfile
}

type AkashaProfileImageSource {
    height: Int!
    src: URI!
    width: Int!
}

type AkashaProfileImageVersions {
    alternatives: [AkashaProfileImageSource]
    default: AkashaProfileImageSource!
}

type AkashaProfileInterests implements Node {
    "Account controlling the document"
    did: CeramicAccount!
    id: ID!
    topics: [AkashaProfileInterestsLabeled!]!
}

"A connection to a list of items."
type AkashaProfileInterestsConnection {
    "A list of edges."
    edges: [AkashaProfileInterestsEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaProfileInterestsEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: AkashaProfileInterests
}

type AkashaProfileInterestsLabeled {
    labelType: String!
    value: String!
}

type AkashaProfileLinkSource {
    href: URI!
    label: String
}

type AkashaProfileStream implements Node {
    active: Boolean!
    createdAt: DateTime!
    id: ID!
    moderationID: CeramicStreamID
    profile: AkashaProfile
    profileID: CeramicStreamID!
    status: AkashaProfileStreamModerationStatus
}

"A connection to a list of items."
type AkashaProfileStreamConnection {
    "A list of edges."
    edges: [AkashaProfileStreamEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaProfileStreamEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: AkashaProfileStream
}

type AkashaReflect implements Node {
    active: Boolean!
    "Account controlling the document"
    author: CeramicAccount!
    beam: AkashaBeam
    beamID: CeramicStreamID!
    content: [AkashaReflectProviderValue!]!
    createdAt: DateTime!
    id: ID!
    isReply: Boolean
    mentions: [CeramicStreamID]
    nsfw: Boolean
    reflection: CeramicStreamID
    tags: [String]
    "Current version of the document"
    version: CeramicCommitID!
}

"A connection to a list of items."
type AkashaReflectConnection {
    "A list of edges."
    edges: [AkashaReflectEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaReflectEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: AkashaReflect
}

type AkashaReflectProviderValue {
    label: String!
    propertyType: String!
    value: String!
}

type AkashaReflectStream implements Node {
    active: Boolean!
    beamID: CeramicStreamID!
    createdAt: DateTime!
    id: ID!
    moderationID: CeramicStreamID
    reflection: AkashaReflect
    reflectionID: CeramicStreamID!
    status: AkashaReflectStreamModerationStatus
}

"A connection to a list of items."
type AkashaReflectStreamConnection {
    "A list of edges."
    edges: [AkashaReflectStreamEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaReflectStreamEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: AkashaReflectStream
}

type CeramicAccount implements Node {
    akashaAppList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaAppFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaAppSortingInput
    ): AkashaAppConnection
    akashaAppListCount(filters: AkashaAppFiltersInput): Int!
    akashaAppReleaseList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaAppReleaseFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaAppReleaseSortingInput
    ): AkashaAppReleaseConnection
    akashaAppReleaseListCount(filters: AkashaAppReleaseFiltersInput): Int!
    akashaAppsStreamList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaAppsStreamFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaAppsStreamSortingInput
    ): AkashaAppsStreamConnection
    akashaAppsStreamListCount(filters: AkashaAppsStreamFiltersInput): Int!
    akashaBeamList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaBeamFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaBeamSortingInput
    ): AkashaBeamConnection
    akashaBeamListCount(filters: AkashaBeamFiltersInput): Int!
    akashaBeamStreamList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaBeamStreamFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaBeamStreamSortingInput
    ): AkashaBeamStreamConnection
    akashaBeamStreamListCount(filters: AkashaBeamStreamFiltersInput): Int!
    akashaBlockStorageList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaBlockStorageFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaBlockStorageSortingInput
    ): AkashaBlockStorageConnection
    akashaBlockStorageListCount(filters: AkashaBlockStorageFiltersInput): Int!
    akashaContentBlockList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaContentBlockFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaContentBlockSortingInput
    ): AkashaContentBlockConnection
    akashaContentBlockListCount(filters: AkashaContentBlockFiltersInput): Int!
    akashaContentBlockStreamList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaContentBlockStreamFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaContentBlockStreamSortingInput
    ): AkashaContentBlockStreamConnection
    akashaContentBlockStreamListCount(filters: AkashaContentBlockStreamFiltersInput): Int!
    akashaFollowList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaFollowFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaFollowSortingInput
    ): AkashaFollowConnection
    akashaFollowListCount(filters: AkashaFollowFiltersInput): Int!
    akashaIndexedStreamList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaIndexedStreamFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaIndexedStreamSortingInput
    ): AkashaIndexedStreamConnection
    akashaIndexedStreamListCount(filters: AkashaIndexedStreamFiltersInput): Int!
    akashaInterestsStreamList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaInterestsStreamFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaInterestsStreamSortingInput
    ): AkashaInterestsStreamConnection
    akashaInterestsStreamListCount(filters: AkashaInterestsStreamFiltersInput): Int!
    akashaProfile: AkashaProfile
    akashaProfileInterests: AkashaProfileInterests
    akashaProfileStreamList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaProfileStreamFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaProfileStreamSortingInput
    ): AkashaProfileStreamConnection
    akashaProfileStreamListCount(filters: AkashaProfileStreamFiltersInput): Int!
    akashaReflectList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaReflectFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaReflectSortingInput
    ): AkashaReflectConnection
    akashaReflectListCount(filters: AkashaReflectFiltersInput): Int!
    akashaReflectStreamList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaReflectStreamFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaReflectStreamSortingInput
    ): AkashaReflectStreamConnection
    akashaReflectStreamListCount(filters: AkashaReflectStreamFiltersInput): Int!
    "Globally unique identifier of the account (DID string)"
    id: ID!
    "Whether the Ceramic instance is currently authenticated with this account or not"
    isViewer: Boolean!
}

type CreateAkashaAppPayload {
    clientMutationId: String
    document: AkashaApp!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateAkashaAppReleasePayload {
    clientMutationId: String
    document: AkashaAppRelease!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateAkashaAppsStreamPayload {
    clientMutationId: String
    document: AkashaAppsStream!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateAkashaBeamPayload {
    clientMutationId: String
    document: AkashaBeam!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateAkashaBeamStreamPayload {
    clientMutationId: String
    document: AkashaBeamStream!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateAkashaBlockStoragePayload {
    clientMutationId: String
    document: AkashaBlockStorage!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateAkashaContentBlockPayload {
    clientMutationId: String
    document: AkashaContentBlock!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateAkashaContentBlockStreamPayload {
    clientMutationId: String
    document: AkashaContentBlockStream!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateAkashaFollowPayload {
    clientMutationId: String
    document: AkashaFollow!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateAkashaIndexedStreamPayload {
    clientMutationId: String
    document: AkashaIndexedStream!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateAkashaInterestsStreamPayload {
    clientMutationId: String
    document: AkashaInterestsStream!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateAkashaProfileInterestsPayload {
    clientMutationId: String
    document: AkashaProfileInterests!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateAkashaProfilePayload {
    clientMutationId: String
    document: AkashaProfile!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateAkashaProfileStreamPayload {
    clientMutationId: String
    document: AkashaProfileStream!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateAkashaReflectPayload {
    clientMutationId: String
    document: AkashaReflect!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateAkashaReflectStreamPayload {
    clientMutationId: String
    document: AkashaReflectStream!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type EnableIndexingAkashaAppPayload {
    clientMutationId: String
    document: AkashaApp
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type EnableIndexingAkashaAppReleasePayload {
    clientMutationId: String
    document: AkashaAppRelease
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type EnableIndexingAkashaAppsStreamPayload {
    clientMutationId: String
    document: AkashaAppsStream
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type EnableIndexingAkashaBeamPayload {
    clientMutationId: String
    document: AkashaBeam
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type EnableIndexingAkashaBeamStreamPayload {
    clientMutationId: String
    document: AkashaBeamStream
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type EnableIndexingAkashaBlockStoragePayload {
    clientMutationId: String
    document: AkashaBlockStorage
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type EnableIndexingAkashaContentBlockPayload {
    clientMutationId: String
    document: AkashaContentBlock
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type EnableIndexingAkashaContentBlockStreamPayload {
    clientMutationId: String
    document: AkashaContentBlockStream
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type EnableIndexingAkashaFollowPayload {
    clientMutationId: String
    document: AkashaFollow
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type EnableIndexingAkashaIndexedStreamPayload {
    clientMutationId: String
    document: AkashaIndexedStream
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type EnableIndexingAkashaInterestsStreamPayload {
    clientMutationId: String
    document: AkashaInterestsStream
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type EnableIndexingAkashaProfileInterestsPayload {
    clientMutationId: String
    document: AkashaProfileInterests
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type EnableIndexingAkashaProfilePayload {
    clientMutationId: String
    document: AkashaProfile
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type EnableIndexingAkashaProfileStreamPayload {
    clientMutationId: String
    document: AkashaProfileStream
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type EnableIndexingAkashaReflectPayload {
    clientMutationId: String
    document: AkashaReflect
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type EnableIndexingAkashaReflectStreamPayload {
    clientMutationId: String
    document: AkashaReflectStream
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type Mutation {
    createAkashaApp(input: CreateAkashaAppInput!): CreateAkashaAppPayload
    createAkashaAppRelease(input: CreateAkashaAppReleaseInput!): CreateAkashaAppReleasePayload
    createAkashaAppsStream(input: CreateAkashaAppsStreamInput!): CreateAkashaAppsStreamPayload
    createAkashaBeam(input: CreateAkashaBeamInput!): CreateAkashaBeamPayload
    createAkashaBeamStream(input: CreateAkashaBeamStreamInput!): CreateAkashaBeamStreamPayload
    createAkashaBlockStorage(input: CreateAkashaBlockStorageInput!): CreateAkashaBlockStoragePayload
    createAkashaContentBlock(input: CreateAkashaContentBlockInput!): CreateAkashaContentBlockPayload
    createAkashaContentBlockStream(input: CreateAkashaContentBlockStreamInput!): CreateAkashaContentBlockStreamPayload
    createAkashaFollow(input: CreateAkashaFollowInput!): CreateAkashaFollowPayload
    createAkashaIndexedStream(input: CreateAkashaIndexedStreamInput!): CreateAkashaIndexedStreamPayload
    createAkashaInterestsStream(input: CreateAkashaInterestsStreamInput!): CreateAkashaInterestsStreamPayload
    createAkashaProfile(input: CreateAkashaProfileInput!): CreateAkashaProfilePayload @deprecated(reason: "Replaced by the setAkashaProfile mutation, createAkashaProfile will be removed in a future version of ComposeDB.")
    createAkashaProfileInterests(input: CreateAkashaProfileInterestsInput!): CreateAkashaProfileInterestsPayload @deprecated(reason: "Replaced by the setAkashaProfileInterests mutation, createAkashaProfileInterests will be removed in a future version of ComposeDB.")
    createAkashaProfileStream(input: CreateAkashaProfileStreamInput!): CreateAkashaProfileStreamPayload
    createAkashaReflect(input: CreateAkashaReflectInput!): CreateAkashaReflectPayload
    createAkashaReflectStream(input: CreateAkashaReflectStreamInput!): CreateAkashaReflectStreamPayload
    enableIndexingAkashaApp(input: EnableIndexingAkashaAppInput!): EnableIndexingAkashaAppPayload
    enableIndexingAkashaAppRelease(input: EnableIndexingAkashaAppReleaseInput!): EnableIndexingAkashaAppReleasePayload
    enableIndexingAkashaAppsStream(input: EnableIndexingAkashaAppsStreamInput!): EnableIndexingAkashaAppsStreamPayload
    enableIndexingAkashaBeam(input: EnableIndexingAkashaBeamInput!): EnableIndexingAkashaBeamPayload
    enableIndexingAkashaBeamStream(input: EnableIndexingAkashaBeamStreamInput!): EnableIndexingAkashaBeamStreamPayload
    enableIndexingAkashaBlockStorage(input: EnableIndexingAkashaBlockStorageInput!): EnableIndexingAkashaBlockStoragePayload
    enableIndexingAkashaContentBlock(input: EnableIndexingAkashaContentBlockInput!): EnableIndexingAkashaContentBlockPayload
    enableIndexingAkashaContentBlockStream(input: EnableIndexingAkashaContentBlockStreamInput!): EnableIndexingAkashaContentBlockStreamPayload
    enableIndexingAkashaFollow(input: EnableIndexingAkashaFollowInput!): EnableIndexingAkashaFollowPayload
    enableIndexingAkashaIndexedStream(input: EnableIndexingAkashaIndexedStreamInput!): EnableIndexingAkashaIndexedStreamPayload
    enableIndexingAkashaInterestsStream(input: EnableIndexingAkashaInterestsStreamInput!): EnableIndexingAkashaInterestsStreamPayload
    enableIndexingAkashaProfile(input: EnableIndexingAkashaProfileInput!): EnableIndexingAkashaProfilePayload
    enableIndexingAkashaProfileInterests(input: EnableIndexingAkashaProfileInterestsInput!): EnableIndexingAkashaProfileInterestsPayload
    enableIndexingAkashaProfileStream(input: EnableIndexingAkashaProfileStreamInput!): EnableIndexingAkashaProfileStreamPayload
    enableIndexingAkashaReflect(input: EnableIndexingAkashaReflectInput!): EnableIndexingAkashaReflectPayload
    enableIndexingAkashaReflectStream(input: EnableIndexingAkashaReflectStreamInput!): EnableIndexingAkashaReflectStreamPayload
    setAkashaProfile(input: SetAkashaProfileInput!): SetAkashaProfilePayload
    setAkashaProfileInterests(input: SetAkashaProfileInterestsInput!): SetAkashaProfileInterestsPayload
    updateAkashaApp(input: UpdateAkashaAppInput!): UpdateAkashaAppPayload
    updateAkashaAppRelease(input: UpdateAkashaAppReleaseInput!): UpdateAkashaAppReleasePayload
    updateAkashaAppsStream(input: UpdateAkashaAppsStreamInput!): UpdateAkashaAppsStreamPayload
    updateAkashaBeam(input: UpdateAkashaBeamInput!): UpdateAkashaBeamPayload
    updateAkashaBeamStream(input: UpdateAkashaBeamStreamInput!): UpdateAkashaBeamStreamPayload
    updateAkashaBlockStorage(input: UpdateAkashaBlockStorageInput!): UpdateAkashaBlockStoragePayload
    updateAkashaContentBlock(input: UpdateAkashaContentBlockInput!): UpdateAkashaContentBlockPayload
    updateAkashaContentBlockStream(input: UpdateAkashaContentBlockStreamInput!): UpdateAkashaContentBlockStreamPayload
    updateAkashaFollow(input: UpdateAkashaFollowInput!): UpdateAkashaFollowPayload
    updateAkashaIndexedStream(input: UpdateAkashaIndexedStreamInput!): UpdateAkashaIndexedStreamPayload
    updateAkashaInterestsStream(input: UpdateAkashaInterestsStreamInput!): UpdateAkashaInterestsStreamPayload
    updateAkashaProfile(input: UpdateAkashaProfileInput!): UpdateAkashaProfilePayload
    updateAkashaProfileInterests(input: UpdateAkashaProfileInterestsInput!): UpdateAkashaProfileInterestsPayload
    updateAkashaProfileStream(input: UpdateAkashaProfileStreamInput!): UpdateAkashaProfileStreamPayload
    updateAkashaReflect(input: UpdateAkashaReflectInput!): UpdateAkashaReflectPayload
    updateAkashaReflectStream(input: UpdateAkashaReflectStreamInput!): UpdateAkashaReflectStreamPayload
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

type Query {
    akashaAppCount(filters: AkashaAppFiltersInput): Int!
    akashaAppIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaAppFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaAppSortingInput
    ): AkashaAppConnection
    akashaAppReleaseCount(filters: AkashaAppReleaseFiltersInput): Int!
    akashaAppReleaseIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaAppReleaseFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaAppReleaseSortingInput
    ): AkashaAppReleaseConnection
    akashaAppsStreamCount(filters: AkashaAppsStreamFiltersInput): Int!
    akashaAppsStreamIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaAppsStreamFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaAppsStreamSortingInput
    ): AkashaAppsStreamConnection
    akashaBeamCount(filters: AkashaBeamFiltersInput): Int!
    akashaBeamIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaBeamFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaBeamSortingInput
    ): AkashaBeamConnection
    akashaBeamStreamCount(filters: AkashaBeamStreamFiltersInput): Int!
    akashaBeamStreamIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaBeamStreamFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaBeamStreamSortingInput
    ): AkashaBeamStreamConnection
    akashaBlockStorageCount(filters: AkashaBlockStorageFiltersInput): Int!
    akashaBlockStorageIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaBlockStorageFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaBlockStorageSortingInput
    ): AkashaBlockStorageConnection
    akashaContentBlockCount(filters: AkashaContentBlockFiltersInput): Int!
    akashaContentBlockIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaContentBlockFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaContentBlockSortingInput
    ): AkashaContentBlockConnection
    akashaContentBlockStreamCount(filters: AkashaContentBlockStreamFiltersInput): Int!
    akashaContentBlockStreamIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaContentBlockStreamFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaContentBlockStreamSortingInput
    ): AkashaContentBlockStreamConnection
    akashaFollowCount(filters: AkashaFollowFiltersInput): Int!
    akashaFollowIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaFollowFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaFollowSortingInput
    ): AkashaFollowConnection
    akashaIndexedStreamCount(filters: AkashaIndexedStreamFiltersInput): Int!
    akashaIndexedStreamIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaIndexedStreamFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaIndexedStreamSortingInput
    ): AkashaIndexedStreamConnection
    akashaInterestsStreamCount(filters: AkashaInterestsStreamFiltersInput): Int!
    akashaInterestsStreamIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaInterestsStreamFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaInterestsStreamSortingInput
    ): AkashaInterestsStreamConnection
    akashaProfileCount(filters: AkashaProfileFiltersInput): Int!
    akashaProfileIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaProfileFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaProfileSortingInput
    ): AkashaProfileConnection
    akashaProfileInterestsCount: Int!
    akashaProfileInterestsIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): AkashaProfileInterestsConnection
    akashaProfileStreamCount(filters: AkashaProfileStreamFiltersInput): Int!
    akashaProfileStreamIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaProfileStreamFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaProfileStreamSortingInput
    ): AkashaProfileStreamConnection
    akashaReflectCount(filters: AkashaReflectFiltersInput): Int!
    akashaReflectIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaReflectFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaReflectSortingInput
    ): AkashaReflectConnection
    akashaReflectStreamCount(filters: AkashaReflectStreamFiltersInput): Int!
    akashaReflectStreamIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        filters: AkashaReflectStreamFiltersInput,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int,
        sorting: AkashaReflectStreamSortingInput
    ): AkashaReflectStreamConnection
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Fetches objects given their IDs"
    nodes(
        "The IDs of objects"
        ids: [ID!]!
    ): [Node]!
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type SetAkashaProfileInterestsPayload {
    clientMutationId: String
    document: AkashaProfileInterests!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type SetAkashaProfilePayload {
    clientMutationId: String
    document: AkashaProfile!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateAkashaAppPayload {
    clientMutationId: String
    document: AkashaApp!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateAkashaAppReleasePayload {
    clientMutationId: String
    document: AkashaAppRelease!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateAkashaAppsStreamPayload {
    clientMutationId: String
    document: AkashaAppsStream!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateAkashaBeamPayload {
    clientMutationId: String
    document: AkashaBeam!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateAkashaBeamStreamPayload {
    clientMutationId: String
    document: AkashaBeamStream!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateAkashaBlockStoragePayload {
    clientMutationId: String
    document: AkashaBlockStorage!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateAkashaContentBlockPayload {
    clientMutationId: String
    document: AkashaContentBlock!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateAkashaContentBlockStreamPayload {
    clientMutationId: String
    document: AkashaContentBlockStream!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateAkashaFollowPayload {
    clientMutationId: String
    document: AkashaFollow!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateAkashaIndexedStreamPayload {
    clientMutationId: String
    document: AkashaIndexedStream!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateAkashaInterestsStreamPayload {
    clientMutationId: String
    document: AkashaInterestsStream!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateAkashaProfileInterestsPayload {
    clientMutationId: String
    document: AkashaProfileInterests!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateAkashaProfilePayload {
    clientMutationId: String
    document: AkashaProfile!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateAkashaProfileStreamPayload {
    clientMutationId: String
    document: AkashaProfileStream!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateAkashaReflectPayload {
    clientMutationId: String
    document: AkashaReflect!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateAkashaReflectStreamPayload {
    clientMutationId: String
    document: AkashaReflectStream!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

enum AkashaAppApplicationType {
    APP
    OTHER
    PLUGIN
    WIDGET
}

enum AkashaAppsStreamModerationStatus {
    IN_REVIEW
    NSFW
    OK
    OTHER
    REMOVED
    SUSPENDED
}

enum AkashaBeamStreamModerationStatus {
    IN_REVIEW
    NSFW
    OK
    OTHER
    REMOVED
    SUSPENDED
}

enum AkashaBlockStorageBlockStorageDef {
    BOOL
    EMOJI
    FORM_DATA
    OTHER
    TEXT
}

enum AkashaContentBlockBlockDef {
    FORM
    OTHER
    TEXT
}

enum AkashaContentBlockStreamModerationStatus {
    IN_REVIEW
    NSFW
    OK
    OTHER
    REMOVED
    SUSPENDED
}

enum AkashaIndexedStreamModerationStatus {
    IN_REVIEW
    NSFW
    OK
    OTHER
    REMOVED
    SUSPENDED
}

enum AkashaIndexedStreamStreamType {
    APP
    BEAM
    EXTENSION
    OTHER
    PLUGIN
    PROFILE
    REFLECT
    WIDGET
}

enum AkashaInterestsStreamModerationStatus {
    IN_REVIEW
    NSFW
    OK
    OTHER
    REMOVED
    SUSPENDED
}

enum AkashaProfileStreamModerationStatus {
    IN_REVIEW
    NSFW
    OK
    OTHER
    REMOVED
    SUSPENDED
}

enum AkashaReflectStreamModerationStatus {
    IN_REVIEW
    NSFW
    OK
    OTHER
    REMOVED
    SUSPENDED
}

enum SortOrder {
    ASC
    DESC
}

"A Ceramic Commit ID"
scalar CeramicCommitID

"A Ceramic Stream ID"
scalar CeramicStreamID

"A field whose value conforms to the standard DID format as specified in did-core: https://www.w3.org/TR/did-core/."
scalar DID

"A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."
scalar DateTime

"A IPLD CID"
scalar InterPlanetaryCID

"A field whose value conforms to the standard Uniform Resource Identifier (URI) format as specified in RFC3986."
scalar URI

input AkashaAppApplicationTypeValueFilterInput {
    equalTo: AkashaAppApplicationType
    in: [AkashaAppApplicationType!]
    isNull: Boolean
    notEqualTo: AkashaAppApplicationType
    notIn: [AkashaAppApplicationType!]
}

input AkashaAppFiltersInput {
    and: [AkashaAppFiltersInput!]
    not: AkashaAppFiltersInput
    or: [AkashaAppFiltersInput!]
    where: AkashaAppObjectFilterInput
}

input AkashaAppInput {
    applicationType: AkashaAppApplicationType
    contributors: [DID]
    createdAt: DateTime!
    description: String!
    displayName: String!
    keywords: [String]
    licence: String!
    name: String!
}

input AkashaAppObjectFilterInput {
    applicationType: AkashaAppApplicationTypeValueFilterInput
    createdAt: StringValueFilterInput
    displayName: StringValueFilterInput
    name: StringValueFilterInput
}

input AkashaAppReleaseFiltersInput {
    and: [AkashaAppReleaseFiltersInput!]
    not: AkashaAppReleaseFiltersInput
    or: [AkashaAppReleaseFiltersInput!]
    where: AkashaAppReleaseObjectFilterInput
}

input AkashaAppReleaseInput {
    applicationID: CeramicStreamID!
    createdAt: DateTime!
    source: InterPlanetaryCID!
    version: String!
}

input AkashaAppReleaseObjectFilterInput {
    applicationID: StringValueFilterInput
    createdAt: StringValueFilterInput
    version: StringValueFilterInput
}

input AkashaAppReleaseSortingInput {
    applicationID: SortOrder
    createdAt: SortOrder
    version: SortOrder
}

input AkashaAppSortingInput {
    applicationType: SortOrder
    createdAt: SortOrder
    displayName: SortOrder
    name: SortOrder
}

input AkashaAppsStreamFiltersInput {
    and: [AkashaAppsStreamFiltersInput!]
    not: AkashaAppsStreamFiltersInput
    or: [AkashaAppsStreamFiltersInput!]
    where: AkashaAppsStreamObjectFilterInput
}

input AkashaAppsStreamInput {
    active: Boolean!
    applicationID: CeramicStreamID!
    createdAt: DateTime!
    moderationID: CeramicStreamID
    status: AkashaAppsStreamModerationStatus
}

input AkashaAppsStreamModerationStatusValueFilterInput {
    equalTo: AkashaAppsStreamModerationStatus
    in: [AkashaAppsStreamModerationStatus!]
    isNull: Boolean
    notEqualTo: AkashaAppsStreamModerationStatus
    notIn: [AkashaAppsStreamModerationStatus!]
}

input AkashaAppsStreamObjectFilterInput {
    active: BooleanValueFilterInput
    applicationID: StringValueFilterInput
    createdAt: StringValueFilterInput
    moderationID: StringValueFilterInput
    status: AkashaAppsStreamModerationStatusValueFilterInput
}

input AkashaAppsStreamSortingInput {
    active: SortOrder
    applicationID: SortOrder
    createdAt: SortOrder
    moderationID: SortOrder
    status: SortOrder
}

input AkashaBeamBlockRecordInput {
    blockID: CeramicStreamID!
    order: Int!
}

input AkashaBeamEmbeddedTypeInput {
    embeddedID: CeramicStreamID!
    label: String!
}

input AkashaBeamFiltersInput {
    and: [AkashaBeamFiltersInput!]
    not: AkashaBeamFiltersInput
    or: [AkashaBeamFiltersInput!]
    where: AkashaBeamObjectFilterInput
}

input AkashaBeamInput {
    active: Boolean!
    content: [AkashaBeamBlockRecordInput]!
    createdAt: DateTime!
    embeddedStream: AkashaBeamEmbeddedTypeInput
    mentions: [DID]
    nsfw: Boolean
    tags: [AkashaBeamLabeledInput]
}

input AkashaBeamLabeledInput {
    labelType: String!
    value: String!
}

input AkashaBeamObjectFilterInput {
    active: BooleanValueFilterInput
    createdAt: StringValueFilterInput
    nsfw: BooleanValueFilterInput
}

input AkashaBeamSortingInput {
    active: SortOrder
    createdAt: SortOrder
    nsfw: SortOrder
}

input AkashaBeamStreamFiltersInput {
    and: [AkashaBeamStreamFiltersInput!]
    not: AkashaBeamStreamFiltersInput
    or: [AkashaBeamStreamFiltersInput!]
    where: AkashaBeamStreamObjectFilterInput
}

input AkashaBeamStreamInput {
    active: Boolean!
    beamID: CeramicStreamID!
    createdAt: DateTime!
    moderationID: CeramicStreamID
    status: AkashaBeamStreamModerationStatus
}

input AkashaBeamStreamModerationStatusValueFilterInput {
    equalTo: AkashaBeamStreamModerationStatus
    in: [AkashaBeamStreamModerationStatus!]
    isNull: Boolean
    notEqualTo: AkashaBeamStreamModerationStatus
    notIn: [AkashaBeamStreamModerationStatus!]
}

input AkashaBeamStreamObjectFilterInput {
    active: BooleanValueFilterInput
    beamID: StringValueFilterInput
    createdAt: StringValueFilterInput
    moderationID: StringValueFilterInput
    status: AkashaBeamStreamModerationStatusValueFilterInput
}

input AkashaBeamStreamSortingInput {
    active: SortOrder
    beamID: SortOrder
    createdAt: SortOrder
    moderationID: SortOrder
    status: SortOrder
}

input AkashaBlockStorageBlockStorageDefValueFilterInput {
    equalTo: AkashaBlockStorageBlockStorageDef
    in: [AkashaBlockStorageBlockStorageDef!]
    isNull: Boolean
    notEqualTo: AkashaBlockStorageBlockStorageDef
    notIn: [AkashaBlockStorageBlockStorageDef!]
}

input AkashaBlockStorageFiltersInput {
    and: [AkashaBlockStorageFiltersInput!]
    not: AkashaBlockStorageFiltersInput
    or: [AkashaBlockStorageFiltersInput!]
    where: AkashaBlockStorageObjectFilterInput
}

input AkashaBlockStorageInput {
    active: Boolean!
    appVersionID: CeramicStreamID!
    blockID: CeramicStreamID!
    content: [AkashaBlockStorageLabeledValueInput]!
    createdAt: DateTime!
    kind: AkashaBlockStorageBlockStorageDef
}

input AkashaBlockStorageLabeledValueInput {
    label: String!
    propertyType: String!
    value: String!
}

input AkashaBlockStorageObjectFilterInput {
    active: BooleanValueFilterInput
    createdAt: StringValueFilterInput
    kind: AkashaBlockStorageBlockStorageDefValueFilterInput
}

input AkashaBlockStorageSortingInput {
    active: SortOrder
    createdAt: SortOrder
    kind: SortOrder
}

input AkashaContentBlockBlockDefValueFilterInput {
    equalTo: AkashaContentBlockBlockDef
    in: [AkashaContentBlockBlockDef!]
    isNull: Boolean
    notEqualTo: AkashaContentBlockBlockDef
    notIn: [AkashaContentBlockBlockDef!]
}

input AkashaContentBlockFiltersInput {
    and: [AkashaContentBlockFiltersInput!]
    not: AkashaContentBlockFiltersInput
    or: [AkashaContentBlockFiltersInput!]
    where: AkashaContentBlockObjectFilterInput
}

input AkashaContentBlockInput {
    active: Boolean!
    appVersionID: CeramicStreamID!
    content: [AkashaContentBlockLabeledValueInput]!
    createdAt: DateTime!
    kind: AkashaContentBlockBlockDef
    nsfw: Boolean
}

input AkashaContentBlockLabeledValueInput {
    label: String!
    propertyType: String!
    value: String!
}

input AkashaContentBlockObjectFilterInput {
    active: BooleanValueFilterInput
    appVersionID: StringValueFilterInput
    createdAt: StringValueFilterInput
    kind: AkashaContentBlockBlockDefValueFilterInput
    nsfw: BooleanValueFilterInput
}

input AkashaContentBlockSortingInput {
    active: SortOrder
    appVersionID: SortOrder
    createdAt: SortOrder
    kind: SortOrder
    nsfw: SortOrder
}

input AkashaContentBlockStreamFiltersInput {
    and: [AkashaContentBlockStreamFiltersInput!]
    not: AkashaContentBlockStreamFiltersInput
    or: [AkashaContentBlockStreamFiltersInput!]
    where: AkashaContentBlockStreamObjectFilterInput
}

input AkashaContentBlockStreamInput {
    active: Boolean!
    blockID: CeramicStreamID!
    createdAt: DateTime!
    moderationID: CeramicStreamID
    status: AkashaContentBlockStreamModerationStatus
}

input AkashaContentBlockStreamModerationStatusValueFilterInput {
    equalTo: AkashaContentBlockStreamModerationStatus
    in: [AkashaContentBlockStreamModerationStatus!]
    isNull: Boolean
    notEqualTo: AkashaContentBlockStreamModerationStatus
    notIn: [AkashaContentBlockStreamModerationStatus!]
}

input AkashaContentBlockStreamObjectFilterInput {
    active: BooleanValueFilterInput
    blockID: StringValueFilterInput
    createdAt: StringValueFilterInput
    moderationID: StringValueFilterInput
    status: AkashaContentBlockStreamModerationStatusValueFilterInput
}

input AkashaContentBlockStreamSortingInput {
    active: SortOrder
    blockID: SortOrder
    createdAt: SortOrder
    moderationID: SortOrder
    status: SortOrder
}

input AkashaFollowFiltersInput {
    and: [AkashaFollowFiltersInput!]
    not: AkashaFollowFiltersInput
    or: [AkashaFollowFiltersInput!]
    where: AkashaFollowObjectFilterInput
}

input AkashaFollowInput {
    isFollowing: Boolean!
    profileID: CeramicStreamID!
}

input AkashaFollowObjectFilterInput {
    isFollowing: BooleanValueFilterInput
    profileID: StringValueFilterInput
}

input AkashaFollowSortingInput {
    isFollowing: SortOrder
    profileID: SortOrder
}

input AkashaIndexedStreamFiltersInput {
    and: [AkashaIndexedStreamFiltersInput!]
    not: AkashaIndexedStreamFiltersInput
    or: [AkashaIndexedStreamFiltersInput!]
    where: AkashaIndexedStreamObjectFilterInput
}

input AkashaIndexedStreamInput {
    active: Boolean!
    createdAt: DateTime!
    indexType: String!
    indexValue: String!
    moderationID: CeramicStreamID
    status: AkashaIndexedStreamModerationStatus
    stream: CeramicStreamID!
    streamType: AkashaIndexedStreamStreamType
}

input AkashaIndexedStreamModerationStatusValueFilterInput {
    equalTo: AkashaIndexedStreamModerationStatus
    in: [AkashaIndexedStreamModerationStatus!]
    isNull: Boolean
    notEqualTo: AkashaIndexedStreamModerationStatus
    notIn: [AkashaIndexedStreamModerationStatus!]
}

input AkashaIndexedStreamObjectFilterInput {
    active: BooleanValueFilterInput
    createdAt: StringValueFilterInput
    indexType: StringValueFilterInput
    indexValue: StringValueFilterInput
    moderationID: StringValueFilterInput
    status: AkashaIndexedStreamModerationStatusValueFilterInput
    stream: StringValueFilterInput
    streamType: AkashaIndexedStreamStreamTypeValueFilterInput
}

input AkashaIndexedStreamSortingInput {
    active: SortOrder
    createdAt: SortOrder
    indexType: SortOrder
    indexValue: SortOrder
    moderationID: SortOrder
    status: SortOrder
    stream: SortOrder
    streamType: SortOrder
}

input AkashaIndexedStreamStreamTypeValueFilterInput {
    equalTo: AkashaIndexedStreamStreamType
    in: [AkashaIndexedStreamStreamType!]
    isNull: Boolean
    notEqualTo: AkashaIndexedStreamStreamType
    notIn: [AkashaIndexedStreamStreamType!]
}

input AkashaInterestsStreamFiltersInput {
    and: [AkashaInterestsStreamFiltersInput!]
    not: AkashaInterestsStreamFiltersInput
    or: [AkashaInterestsStreamFiltersInput!]
    where: AkashaInterestsStreamObjectFilterInput
}

input AkashaInterestsStreamInput {
    active: Boolean!
    createdAt: DateTime!
    labelType: String!
    moderationID: CeramicStreamID
    status: AkashaInterestsStreamModerationStatus
    value: String!
}

input AkashaInterestsStreamModerationStatusValueFilterInput {
    equalTo: AkashaInterestsStreamModerationStatus
    in: [AkashaInterestsStreamModerationStatus!]
    isNull: Boolean
    notEqualTo: AkashaInterestsStreamModerationStatus
    notIn: [AkashaInterestsStreamModerationStatus!]
}

input AkashaInterestsStreamObjectFilterInput {
    active: BooleanValueFilterInput
    createdAt: StringValueFilterInput
    labelType: StringValueFilterInput
    moderationID: StringValueFilterInput
    status: AkashaInterestsStreamModerationStatusValueFilterInput
    value: StringValueFilterInput
}

input AkashaInterestsStreamSortingInput {
    active: SortOrder
    createdAt: SortOrder
    labelType: SortOrder
    moderationID: SortOrder
    status: SortOrder
    value: SortOrder
}

input AkashaProfileFiltersInput {
    and: [AkashaProfileFiltersInput!]
    not: AkashaProfileFiltersInput
    or: [AkashaProfileFiltersInput!]
    where: AkashaProfileObjectFilterInput
}

input AkashaProfileImageSourceInput {
    height: Int!
    src: URI!
    width: Int!
}

input AkashaProfileImageVersionsInput {
    alternatives: [AkashaProfileImageSourceInput]
    default: AkashaProfileImageSourceInput!
}

input AkashaProfileInput {
    avatar: AkashaProfileImageVersionsInput
    background: AkashaProfileImageVersionsInput
    createdAt: DateTime!
    description: String
    links: [AkashaProfileLinkSourceInput]
    name: String!
    nsfw: Boolean
}

input AkashaProfileInterestsInput {
    topics: [AkashaProfileInterestsLabeledInput]!
}

input AkashaProfileInterestsLabeledInput {
    labelType: String!
    value: String!
}

input AkashaProfileLinkSourceInput {
    href: URI!
    label: String
}

input AkashaProfileObjectFilterInput {
    createdAt: StringValueFilterInput
    name: StringValueFilterInput
    nsfw: BooleanValueFilterInput
}

input AkashaProfileSortingInput {
    createdAt: SortOrder
    name: SortOrder
    nsfw: SortOrder
}

input AkashaProfileStreamFiltersInput {
    and: [AkashaProfileStreamFiltersInput!]
    not: AkashaProfileStreamFiltersInput
    or: [AkashaProfileStreamFiltersInput!]
    where: AkashaProfileStreamObjectFilterInput
}

input AkashaProfileStreamInput {
    active: Boolean!
    createdAt: DateTime!
    moderationID: CeramicStreamID
    profileID: CeramicStreamID!
    status: AkashaProfileStreamModerationStatus
}

input AkashaProfileStreamModerationStatusValueFilterInput {
    equalTo: AkashaProfileStreamModerationStatus
    in: [AkashaProfileStreamModerationStatus!]
    isNull: Boolean
    notEqualTo: AkashaProfileStreamModerationStatus
    notIn: [AkashaProfileStreamModerationStatus!]
}

input AkashaProfileStreamObjectFilterInput {
    active: BooleanValueFilterInput
    createdAt: StringValueFilterInput
    moderationID: StringValueFilterInput
    profileID: StringValueFilterInput
    status: AkashaProfileStreamModerationStatusValueFilterInput
}

input AkashaProfileStreamSortingInput {
    active: SortOrder
    createdAt: SortOrder
    moderationID: SortOrder
    profileID: SortOrder
    status: SortOrder
}

input AkashaReflectFiltersInput {
    and: [AkashaReflectFiltersInput!]
    not: AkashaReflectFiltersInput
    or: [AkashaReflectFiltersInput!]
    where: AkashaReflectObjectFilterInput
}

input AkashaReflectInput {
    active: Boolean!
    beamID: CeramicStreamID!
    content: [AkashaReflectProviderValueInput]!
    createdAt: DateTime!
    isReply: Boolean
    mentions: [CeramicStreamID]
    nsfw: Boolean
    reflection: CeramicStreamID
    tags: [String]
}

input AkashaReflectObjectFilterInput {
    active: BooleanValueFilterInput
    createdAt: StringValueFilterInput
    isReply: BooleanValueFilterInput
    nsfw: BooleanValueFilterInput
    reflection: StringValueFilterInput
}

input AkashaReflectProviderValueInput {
    label: String!
    propertyType: String!
    value: String!
}

input AkashaReflectSortingInput {
    active: SortOrder
    createdAt: SortOrder
    isReply: SortOrder
    nsfw: SortOrder
    reflection: SortOrder
}

input AkashaReflectStreamFiltersInput {
    and: [AkashaReflectStreamFiltersInput!]
    not: AkashaReflectStreamFiltersInput
    or: [AkashaReflectStreamFiltersInput!]
    where: AkashaReflectStreamObjectFilterInput
}

input AkashaReflectStreamInput {
    active: Boolean!
    beamID: CeramicStreamID!
    createdAt: DateTime!
    moderationID: CeramicStreamID
    reflectionID: CeramicStreamID!
    status: AkashaReflectStreamModerationStatus
}

input AkashaReflectStreamModerationStatusValueFilterInput {
    equalTo: AkashaReflectStreamModerationStatus
    in: [AkashaReflectStreamModerationStatus!]
    isNull: Boolean
    notEqualTo: AkashaReflectStreamModerationStatus
    notIn: [AkashaReflectStreamModerationStatus!]
}

input AkashaReflectStreamObjectFilterInput {
    active: BooleanValueFilterInput
    beamID: StringValueFilterInput
    createdAt: StringValueFilterInput
    moderationID: StringValueFilterInput
    reflectionID: StringValueFilterInput
    status: AkashaReflectStreamModerationStatusValueFilterInput
}

input AkashaReflectStreamSortingInput {
    active: SortOrder
    beamID: SortOrder
    createdAt: SortOrder
    moderationID: SortOrder
    reflectionID: SortOrder
    status: SortOrder
}

input BooleanValueFilterInput {
    equalTo: Boolean
    isNull: Boolean
}

input CreateAkashaAppInput {
    clientMutationId: String
    content: AkashaAppInput!
    options: CreateOptionsInput
}

input CreateAkashaAppReleaseInput {
    clientMutationId: String
    content: AkashaAppReleaseInput!
    options: CreateOptionsInput
}

input CreateAkashaAppsStreamInput {
    clientMutationId: String
    content: AkashaAppsStreamInput!
    options: CreateOptionsInput
}

input CreateAkashaBeamInput {
    clientMutationId: String
    content: AkashaBeamInput!
    options: CreateOptionsInput
}

input CreateAkashaBeamStreamInput {
    clientMutationId: String
    content: AkashaBeamStreamInput!
    options: CreateOptionsInput
}

input CreateAkashaBlockStorageInput {
    clientMutationId: String
    content: AkashaBlockStorageInput!
    options: CreateOptionsInput
}

input CreateAkashaContentBlockInput {
    clientMutationId: String
    content: AkashaContentBlockInput!
    options: CreateOptionsInput
}

input CreateAkashaContentBlockStreamInput {
    clientMutationId: String
    content: AkashaContentBlockStreamInput!
    options: CreateOptionsInput
}

input CreateAkashaFollowInput {
    clientMutationId: String
    content: AkashaFollowInput!
    options: CreateOptionsInput
}

input CreateAkashaIndexedStreamInput {
    clientMutationId: String
    content: AkashaIndexedStreamInput!
    options: CreateOptionsInput
}

input CreateAkashaInterestsStreamInput {
    clientMutationId: String
    content: AkashaInterestsStreamInput!
    options: CreateOptionsInput
}

input CreateAkashaProfileInput {
    clientMutationId: String
    content: AkashaProfileInput!
    options: SetOptionsInput
}

input CreateAkashaProfileInterestsInput {
    clientMutationId: String
    content: AkashaProfileInterestsInput!
    options: SetOptionsInput
}

input CreateAkashaProfileStreamInput {
    clientMutationId: String
    content: AkashaProfileStreamInput!
    options: CreateOptionsInput
}

input CreateAkashaReflectInput {
    clientMutationId: String
    content: AkashaReflectInput!
    options: CreateOptionsInput
}

input CreateAkashaReflectStreamInput {
    clientMutationId: String
    content: AkashaReflectStreamInput!
    options: CreateOptionsInput
}

input CreateOptionsInput {
    "Inform indexers if they should index this document or not"
    shouldIndex: Boolean
}

input EnableIndexingAkashaAppInput {
    clientMutationId: String
    id: ID!
    shouldIndex: Boolean!
}

input EnableIndexingAkashaAppReleaseInput {
    clientMutationId: String
    id: ID!
    shouldIndex: Boolean!
}

input EnableIndexingAkashaAppsStreamInput {
    clientMutationId: String
    id: ID!
    shouldIndex: Boolean!
}

input EnableIndexingAkashaBeamInput {
    clientMutationId: String
    id: ID!
    shouldIndex: Boolean!
}

input EnableIndexingAkashaBeamStreamInput {
    clientMutationId: String
    id: ID!
    shouldIndex: Boolean!
}

input EnableIndexingAkashaBlockStorageInput {
    clientMutationId: String
    id: ID!
    shouldIndex: Boolean!
}

input EnableIndexingAkashaContentBlockInput {
    clientMutationId: String
    id: ID!
    shouldIndex: Boolean!
}

input EnableIndexingAkashaContentBlockStreamInput {
    clientMutationId: String
    id: ID!
    shouldIndex: Boolean!
}

input EnableIndexingAkashaFollowInput {
    clientMutationId: String
    id: ID!
    shouldIndex: Boolean!
}

input EnableIndexingAkashaIndexedStreamInput {
    clientMutationId: String
    id: ID!
    shouldIndex: Boolean!
}

input EnableIndexingAkashaInterestsStreamInput {
    clientMutationId: String
    id: ID!
    shouldIndex: Boolean!
}

input EnableIndexingAkashaProfileInput {
    clientMutationId: String
    id: ID!
    shouldIndex: Boolean!
}

input EnableIndexingAkashaProfileInterestsInput {
    clientMutationId: String
    id: ID!
    shouldIndex: Boolean!
}

input EnableIndexingAkashaProfileStreamInput {
    clientMutationId: String
    id: ID!
    shouldIndex: Boolean!
}

input EnableIndexingAkashaReflectInput {
    clientMutationId: String
    id: ID!
    shouldIndex: Boolean!
}

input EnableIndexingAkashaReflectStreamInput {
    clientMutationId: String
    id: ID!
    shouldIndex: Boolean!
}

input PartialAkashaAppInput {
    applicationType: AkashaAppApplicationType
    contributors: [DID]
    createdAt: DateTime
    description: String
    displayName: String
    keywords: [String]
    licence: String
    name: String
}

input PartialAkashaAppReleaseInput {
    applicationID: CeramicStreamID
    createdAt: DateTime
    source: InterPlanetaryCID
    version: String
}

input PartialAkashaAppsStreamInput {
    active: Boolean
    applicationID: CeramicStreamID
    createdAt: DateTime
    moderationID: CeramicStreamID
    status: AkashaAppsStreamModerationStatus
}

input PartialAkashaBeamInput {
    active: Boolean
    content: [AkashaBeamBlockRecordInput]
    createdAt: DateTime
    embeddedStream: AkashaBeamEmbeddedTypeInput
    mentions: [DID]
    nsfw: Boolean
    tags: [AkashaBeamLabeledInput]
}

input PartialAkashaBeamStreamInput {
    active: Boolean
    beamID: CeramicStreamID
    createdAt: DateTime
    moderationID: CeramicStreamID
    status: AkashaBeamStreamModerationStatus
}

input PartialAkashaBlockStorageInput {
    active: Boolean
    appVersionID: CeramicStreamID
    blockID: CeramicStreamID
    content: [AkashaBlockStorageLabeledValueInput]
    createdAt: DateTime
    kind: AkashaBlockStorageBlockStorageDef
}

input PartialAkashaContentBlockInput {
    active: Boolean
    appVersionID: CeramicStreamID
    content: [AkashaContentBlockLabeledValueInput]
    createdAt: DateTime
    kind: AkashaContentBlockBlockDef
    nsfw: Boolean
}

input PartialAkashaContentBlockStreamInput {
    active: Boolean
    blockID: CeramicStreamID
    createdAt: DateTime
    moderationID: CeramicStreamID
    status: AkashaContentBlockStreamModerationStatus
}

input PartialAkashaFollowInput {
    isFollowing: Boolean
    profileID: CeramicStreamID
}

input PartialAkashaIndexedStreamInput {
    active: Boolean
    createdAt: DateTime
    indexType: String
    indexValue: String
    moderationID: CeramicStreamID
    status: AkashaIndexedStreamModerationStatus
    stream: CeramicStreamID
    streamType: AkashaIndexedStreamStreamType
}

input PartialAkashaInterestsStreamInput {
    active: Boolean
    createdAt: DateTime
    labelType: String
    moderationID: CeramicStreamID
    status: AkashaInterestsStreamModerationStatus
    value: String
}

input PartialAkashaProfileInput {
    avatar: AkashaProfileImageVersionsInput
    background: AkashaProfileImageVersionsInput
    createdAt: DateTime
    description: String
    links: [AkashaProfileLinkSourceInput]
    name: String
    nsfw: Boolean
}

input PartialAkashaProfileInterestsInput {
    topics: [AkashaProfileInterestsLabeledInput]
}

input PartialAkashaProfileStreamInput {
    active: Boolean
    createdAt: DateTime
    moderationID: CeramicStreamID
    profileID: CeramicStreamID
    status: AkashaProfileStreamModerationStatus
}

input PartialAkashaReflectInput {
    active: Boolean
    beamID: CeramicStreamID
    content: [AkashaReflectProviderValueInput]
    createdAt: DateTime
    isReply: Boolean
    mentions: [CeramicStreamID]
    nsfw: Boolean
    reflection: CeramicStreamID
    tags: [String]
}

input PartialAkashaReflectStreamInput {
    active: Boolean
    beamID: CeramicStreamID
    createdAt: DateTime
    moderationID: CeramicStreamID
    reflectionID: CeramicStreamID
    status: AkashaReflectStreamModerationStatus
}

input SetAkashaProfileInput {
    clientMutationId: String
    content: AkashaProfileInput!
    options: SetOptionsInput
}

input SetAkashaProfileInterestsInput {
    clientMutationId: String
    content: AkashaProfileInterestsInput!
    options: SetOptionsInput
}

input SetOptionsInput {
    "Inform indexers if they should index this document or not"
    shouldIndex: Boolean
    "Maximum amount of time to lookup the stream over the network, in seconds - see https://developers.ceramic.network/reference/typescript/interfaces/_ceramicnetwork_common.CreateOpts.html#syncTimeoutSeconds"
    syncTimeout: Int
}

input StringValueFilterInput {
    equalTo: String
    greaterThan: String
    greaterThanOrEqualTo: String
    in: [String!]
    isNull: Boolean
    lessThan: String
    lessThanOrEqualTo: String
    notEqualTo: String
    notIn: [String!]
}

input UpdateAkashaAppInput {
    clientMutationId: String
    content: PartialAkashaAppInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateAkashaAppReleaseInput {
    clientMutationId: String
    content: PartialAkashaAppReleaseInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateAkashaAppsStreamInput {
    clientMutationId: String
    content: PartialAkashaAppsStreamInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateAkashaBeamInput {
    clientMutationId: String
    content: PartialAkashaBeamInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateAkashaBeamStreamInput {
    clientMutationId: String
    content: PartialAkashaBeamStreamInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateAkashaBlockStorageInput {
    clientMutationId: String
    content: PartialAkashaBlockStorageInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateAkashaContentBlockInput {
    clientMutationId: String
    content: PartialAkashaContentBlockInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateAkashaContentBlockStreamInput {
    clientMutationId: String
    content: PartialAkashaContentBlockStreamInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateAkashaFollowInput {
    clientMutationId: String
    content: PartialAkashaFollowInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateAkashaIndexedStreamInput {
    clientMutationId: String
    content: PartialAkashaIndexedStreamInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateAkashaInterestsStreamInput {
    clientMutationId: String
    content: PartialAkashaInterestsStreamInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateAkashaProfileInput {
    clientMutationId: String
    content: PartialAkashaProfileInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateAkashaProfileInterestsInput {
    clientMutationId: String
    content: PartialAkashaProfileInterestsInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateAkashaProfileStreamInput {
    clientMutationId: String
    content: PartialAkashaProfileStreamInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateAkashaReflectInput {
    clientMutationId: String
    content: PartialAkashaReflectInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateAkashaReflectStreamInput {
    clientMutationId: String
    content: PartialAkashaReflectStreamInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateOptionsInput {
    "Fully replace the document contents instead of performing a shallow merge"
    replace: Boolean = false
    "Inform indexers if they should index this document or not"
    shouldIndex: Boolean
    "Only perform mutation if the document matches the provided version"
    version: CeramicCommitID
}
