# This file was generated. Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"An object with an ID"
interface Node {
    "The id of the object."
    id: ID!
}

type AkashaApp implements Node {
    applicationType: AkashaAppApplicationType
    "Account controlling the document"
    author: CeramicAccount!
    contributors: [CeramicAccount]
    createdAt: DateTime!
    description: String!
    displayName: String!
    id: ID!
    keywords: [String]
    licence: String!
    name: String!
    releases(
        "Returns only documents created by the provided account"
        account: ID,
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): AppReleaseConnection!
    releasessCount(
        "Counts only documents created by the provided account"
        account: ID
    ): Int!
}

"A connection to a list of items."
type AkashaAppConnection {
    "A list of edges."
    edges: [AkashaAppEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaAppEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: AkashaApp
}

type AppRelease implements Node {
    application: AkashaApp
    applicationID: CeramicStreamID!
    createdAt: DateTime!
    id: ID!
    source: InterPlanetaryCID!
    version: String!
}

"A connection to a list of items."
type AppReleaseConnection {
    "A list of edges."
    edges: [AppReleaseEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AppReleaseEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: AppRelease
}

type Beam implements Node {
    active: Boolean!
    "Account controlling the document"
    author: CeramicAccount!
    content: [BeamProviderValue!]!
    createdAt: DateTime!
    id: ID!
    mentions(
        "Returns only documents created by the provided account"
        account: ID,
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): ProfileMentionConnection!
    rebeams(
        "Returns only documents created by the provided account"
        account: ID,
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): RebeamConnection!
    rebeamsCount(
        "Counts only documents created by the provided account"
        account: ID
    ): Int!
    reflections(
        "Returns only documents created by the provided account"
        account: ID,
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): ReflectConnection!
    reflectionsCount(
        "Counts only documents created by the provided account"
        account: ID
    ): Int!
    tags: [String]
    "Current version of the document"
    version: CeramicCommitID!
}

"A connection to a list of items."
type BeamConnection {
    "A list of edges."
    edges: [BeamEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type BeamEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: Beam
}

type BeamProviderValue {
    property: String!
    provider: String!
    value: String!
}

type CeramicAccount implements Node {
    akashaAppList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): AkashaAppConnection
    appReleaseList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): AppReleaseConnection
    beamList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): BeamConnection
    followList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): FollowConnection
    "Globally unique identifier of the account (DID string)"
    id: ID!
    interests: Interests
    "Whether the Ceramic instance is currently authenticated with this account or not"
    isViewer: Boolean!
    profile: Profile
    profileMentionList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): ProfileMentionConnection
    rebeamList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): RebeamConnection
    reflectList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): ReflectConnection
    reflectionList(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): ReflectionConnection
}

type CreateAkashaAppPayload {
    clientMutationId: String
    document: AkashaApp!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateAppReleasePayload {
    clientMutationId: String
    document: AppRelease!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateBeamPayload {
    clientMutationId: String
    document: Beam!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateFollowPayload {
    clientMutationId: String
    document: Follow!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateInterestsPayload {
    clientMutationId: String
    document: Interests!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateProfileMentionPayload {
    clientMutationId: String
    document: ProfileMention!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateProfilePayload {
    clientMutationId: String
    document: Profile!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateRebeamPayload {
    clientMutationId: String
    document: Rebeam!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateReflectPayload {
    clientMutationId: String
    document: Reflect!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type CreateReflectionPayload {
    clientMutationId: String
    document: Reflection!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type Follow implements Node {
    "Account controlling the document"
    did: CeramicAccount!
    id: ID!
    isFollowing: Boolean!
    profile: Profile
    profileID: CeramicStreamID!
}

"A connection to a list of items."
type FollowConnection {
    "A list of edges."
    edges: [FollowEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type FollowEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: Follow
}

type Interests implements Node {
    "Account controlling the document"
    did: CeramicAccount!
    id: ID!
    topics: [InterestsLabeled!]!
}

"A connection to a list of items."
type InterestsConnection {
    "A list of edges."
    edges: [InterestsEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type InterestsEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: Interests
}

type InterestsLabeled {
    labelType: String!
    value: String!
}

type Mutation {
    createAkashaApp(input: CreateAkashaAppInput!): CreateAkashaAppPayload
    createAppRelease(input: CreateAppReleaseInput!): CreateAppReleasePayload
    createBeam(input: CreateBeamInput!): CreateBeamPayload
    createFollow(input: CreateFollowInput!): CreateFollowPayload
    createInterests(input: CreateInterestsInput!): CreateInterestsPayload
    createProfile(input: CreateProfileInput!): CreateProfilePayload
    createProfileMention(input: CreateProfileMentionInput!): CreateProfileMentionPayload
    createRebeam(input: CreateRebeamInput!): CreateRebeamPayload
    createReflect(input: CreateReflectInput!): CreateReflectPayload
    createReflection(input: CreateReflectionInput!): CreateReflectionPayload
    updateAkashaApp(input: UpdateAkashaAppInput!): UpdateAkashaAppPayload
    updateAppRelease(input: UpdateAppReleaseInput!): UpdateAppReleasePayload
    updateBeam(input: UpdateBeamInput!): UpdateBeamPayload
    updateFollow(input: UpdateFollowInput!): UpdateFollowPayload
    updateInterests(input: UpdateInterestsInput!): UpdateInterestsPayload
    updateProfile(input: UpdateProfileInput!): UpdateProfilePayload
    updateProfileMention(input: UpdateProfileMentionInput!): UpdateProfileMentionPayload
    updateRebeam(input: UpdateRebeamInput!): UpdateRebeamPayload
    updateReflect(input: UpdateReflectInput!): UpdateReflectPayload
    updateReflection(input: UpdateReflectionInput!): UpdateReflectionPayload
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

type Profile implements Node {
    avatar: ProfileImageVersions
    background: ProfileImageVersions
    createdAt: DateTime!
    description: String
    "Account controlling the document"
    did: CeramicAccount!
    followers(
        "Returns only documents created by the provided account"
        account: ID,
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): FollowConnection!
    id: ID!
    links: [ProfileLinkSource]
    name: String!
}

"A connection to a list of items."
type ProfileConnection {
    "A list of edges."
    edges: [ProfileEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type ProfileEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: Profile
}

type ProfileImageSource {
    height: Int!
    src: URI!
    width: Int!
}

type ProfileImageVersions {
    alternatives: [ProfileImageSource]
    default: ProfileImageSource!
}

type ProfileLinkSource {
    href: URI!
    label: String
}

type ProfileMention implements Node {
    beam: Beam
    beamID: CeramicStreamID!
    id: ID!
    profile: Profile
    profileID: CeramicStreamID!
}

"A connection to a list of items."
type ProfileMentionConnection {
    "A list of edges."
    edges: [ProfileMentionEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type ProfileMentionEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: ProfileMention
}

type Query {
    akashaAppIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): AkashaAppConnection
    appReleaseIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): AppReleaseConnection
    beamIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): BeamConnection
    followIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): FollowConnection
    interestsIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): InterestsConnection
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    profileIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): ProfileConnection
    profileMentionIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): ProfileMentionConnection
    rebeamIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): RebeamConnection
    reflectIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): ReflectConnection
    reflectionIndex(
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): ReflectionConnection
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type Rebeam implements Node {
    active: Boolean!
    beam: Beam
    beamID: CeramicStreamID!
    id: ID!
    quotedBeam: Beam
    quotedBeamID: CeramicStreamID!
}

"A connection to a list of items."
type RebeamConnection {
    "A list of edges."
    edges: [RebeamEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type RebeamEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: Rebeam
}

type Reflect implements Node {
    active: Boolean!
    "Account controlling the document"
    author: CeramicAccount!
    beam: Beam
    beamID: CeramicStreamID!
    content: [ReflectProviderValue!]!
    createdAt: DateTime!
    id: ID!
    isReply: Boolean!
    reflections(
        "Returns only documents created by the provided account"
        account: ID,
        "Returns the items in the list that come after the specified cursor."
        after: String,
        "Returns the items in the list that come before the specified cursor."
        before: String,
        "Returns the first n items from the list."
        first: Int,
        "Returns the last n items from the list."
        last: Int
    ): ReflectionConnection!
    reflectionsCount(
        "Counts only documents created by the provided account"
        account: ID
    ): Int!
    "Current version of the document"
    version: CeramicCommitID!
}

"A connection to a list of items."
type ReflectConnection {
    "A list of edges."
    edges: [ReflectEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type ReflectEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: Reflect
}

type ReflectProviderValue {
    property: String!
    provider: String!
    value: String!
}

type Reflection implements Node {
    active: Boolean!
    id: ID!
    reflect: Reflect
    reflectID: CeramicStreamID!
    reflection: Reflect
    reflectionID: CeramicStreamID!
}

"A connection to a list of items."
type ReflectionConnection {
    "A list of edges."
    edges: [ReflectionEdge]
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type ReflectionEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: Reflection
}

type UpdateAkashaAppPayload {
    clientMutationId: String
    document: AkashaApp!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateAppReleasePayload {
    clientMutationId: String
    document: AppRelease!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateBeamPayload {
    clientMutationId: String
    document: Beam!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateFollowPayload {
    clientMutationId: String
    document: Follow!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateInterestsPayload {
    clientMutationId: String
    document: Interests!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateProfileMentionPayload {
    clientMutationId: String
    document: ProfileMention!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateProfilePayload {
    clientMutationId: String
    document: Profile!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateRebeamPayload {
    clientMutationId: String
    document: Rebeam!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateReflectPayload {
    clientMutationId: String
    document: Reflect!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

type UpdateReflectionPayload {
    clientMutationId: String
    document: Reflection!
    "Fetches an object given its ID"
    node(
        "The ID of an object"
        id: ID!
    ): Node
    "Account currently authenticated on the Ceramic instance, if set"
    viewer: CeramicAccount
}

enum AkashaAppApplicationType {
    APP
    OTHER
    PLUGIN
    WIDGET
}

"A Ceramic Commit ID"
scalar CeramicCommitID

"A Ceramic Stream ID"
scalar CeramicStreamID

"A field whose value conforms to the standard DID format as specified in did-core: https://www.w3.org/TR/did-core/."
scalar DID

"A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."
scalar DateTime

"A IPLD CID"
scalar InterPlanetaryCID

"A field whose value conforms to the standard Uniform Resource Identifier (URI) format as specified in RFC3986."
scalar URI

input AkashaAppInput {
    applicationType: AkashaAppApplicationType
    contributors: [DID]
    createdAt: DateTime!
    description: String!
    displayName: String!
    keywords: [String]
    licence: String!
    name: String!
}

input AppReleaseInput {
    applicationID: CeramicStreamID!
    createdAt: DateTime!
    source: InterPlanetaryCID!
    version: String!
}

input BeamInput {
    active: Boolean!
    content: [BeamProviderValueInput]!
    createdAt: DateTime!
    tags: [String]
}

input BeamProviderValueInput {
    property: String!
    provider: String!
    value: String!
}

input CreateAkashaAppInput {
    clientMutationId: String
    content: AkashaAppInput!
}

input CreateAppReleaseInput {
    clientMutationId: String
    content: AppReleaseInput!
}

input CreateBeamInput {
    clientMutationId: String
    content: BeamInput!
}

input CreateFollowInput {
    clientMutationId: String
    content: FollowInput!
}

input CreateInterestsInput {
    clientMutationId: String
    content: InterestsInput!
}

input CreateProfileInput {
    clientMutationId: String
    content: ProfileInput!
}

input CreateProfileMentionInput {
    clientMutationId: String
    content: ProfileMentionInput!
}

input CreateRebeamInput {
    clientMutationId: String
    content: RebeamInput!
}

input CreateReflectInput {
    clientMutationId: String
    content: ReflectInput!
}

input CreateReflectionInput {
    clientMutationId: String
    content: ReflectionInput!
}

input FollowInput {
    isFollowing: Boolean!
    profileID: CeramicStreamID!
}

input InterestsInput {
    topics: [InterestsLabeledInput]!
}

input InterestsLabeledInput {
    labelType: String!
    value: String!
}

input PartialAkashaAppInput {
    applicationType: AkashaAppApplicationType
    contributors: [DID]
    createdAt: DateTime
    description: String
    displayName: String
    keywords: [String]
    licence: String
    name: String
}

input PartialAppReleaseInput {
    applicationID: CeramicStreamID
    createdAt: DateTime
    source: InterPlanetaryCID
    version: String
}

input PartialBeamInput {
    active: Boolean
    content: [BeamProviderValueInput]
    createdAt: DateTime
    tags: [String]
}

input PartialFollowInput {
    isFollowing: Boolean
    profileID: CeramicStreamID
}

input PartialInterestsInput {
    topics: [InterestsLabeledInput]
}

input PartialProfileInput {
    avatar: ProfileImageVersionsInput
    background: ProfileImageVersionsInput
    createdAt: DateTime
    description: String
    links: [ProfileLinkSourceInput]
    name: String
}

input PartialProfileMentionInput {
    beamID: CeramicStreamID
    profileID: CeramicStreamID
}

input PartialRebeamInput {
    active: Boolean
    beamID: CeramicStreamID
    quotedBeamID: CeramicStreamID
}

input PartialReflectInput {
    active: Boolean
    beamID: CeramicStreamID
    content: [ReflectProviderValueInput]
    createdAt: DateTime
    isReply: Boolean
}

input PartialReflectionInput {
    active: Boolean
    reflectID: CeramicStreamID
    reflectionID: CeramicStreamID
}

input ProfileImageSourceInput {
    height: Int!
    src: URI!
    width: Int!
}

input ProfileImageVersionsInput {
    alternatives: [ProfileImageSourceInput]
    default: ProfileImageSourceInput!
}

input ProfileInput {
    avatar: ProfileImageVersionsInput
    background: ProfileImageVersionsInput
    createdAt: DateTime!
    description: String
    links: [ProfileLinkSourceInput]
    name: String!
}

input ProfileLinkSourceInput {
    href: URI!
    label: String
}

input ProfileMentionInput {
    beamID: CeramicStreamID!
    profileID: CeramicStreamID!
}

input RebeamInput {
    active: Boolean!
    beamID: CeramicStreamID!
    quotedBeamID: CeramicStreamID!
}

input ReflectInput {
    active: Boolean!
    beamID: CeramicStreamID!
    content: [ReflectProviderValueInput]!
    createdAt: DateTime!
    isReply: Boolean!
}

input ReflectProviderValueInput {
    property: String!
    provider: String!
    value: String!
}

input ReflectionInput {
    active: Boolean!
    reflectID: CeramicStreamID!
    reflectionID: CeramicStreamID!
}

input UpdateAkashaAppInput {
    clientMutationId: String
    content: PartialAkashaAppInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateAppReleaseInput {
    clientMutationId: String
    content: PartialAppReleaseInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateBeamInput {
    clientMutationId: String
    content: PartialBeamInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateFollowInput {
    clientMutationId: String
    content: PartialFollowInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateInterestsInput {
    clientMutationId: String
    content: PartialInterestsInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateOptionsInput {
    "Fully replace the document contents instead of performing a shallow merge"
    replace: Boolean = false
    "Only perform mutation if the document matches the provided version"
    version: CeramicCommitID
}

input UpdateProfileInput {
    clientMutationId: String
    content: PartialProfileInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateProfileMentionInput {
    clientMutationId: String
    content: PartialProfileMentionInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateRebeamInput {
    clientMutationId: String
    content: PartialRebeamInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateReflectInput {
    clientMutationId: String
    content: PartialReflectInput!
    id: ID!
    options: UpdateOptionsInput
}

input UpdateReflectionInput {
    clientMutationId: String
    content: PartialReflectionInput!
    id: ID!
    options: UpdateOptionsInput
}
