# This file was generated. Do not edit manually.

schema {
  query: Query
  mutation: Mutation
}

"An object with an ID"
interface Node {
  "The id of the object."
  id: ID!
}

type AkashaApp implements Node {
  applicationType: AkashaAppApplicationType
  "Account controlling the document"
  author: CeramicAccount!
  contributors: [CeramicAccount]
  createdAt: DateTime!
  description: String!
  displayName: String!
  id: ID!
  keywords: [String]
  licence: String!
  name: String!
  releases(
    "Returns only documents created by the provided account"
    account: ID,
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaAppReleaseFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaAppReleaseSortingInput
  ): AkashaAppReleaseConnection!
  releasesCount(
    "Counts only documents created by the provided account"
    account: ID,
    filters: AkashaAppReleaseFiltersInput
  ): Int!
}

"A connection to a list of items."
type AkashaAppConnection {
  "A list of edges."
  edges: [AkashaAppEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaAppEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaApp
}

type AkashaAppRelease implements Node {
  application: AkashaApp
  applicationID: CeramicStreamID!
  createdAt: DateTime!
  id: ID!
  source: InterPlanetaryCID!
  version: String!
}

"A connection to a list of items."
type AkashaAppReleaseConnection {
  "A list of edges."
  edges: [AkashaAppReleaseEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaAppReleaseEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaAppRelease
}

type AkashaBeam implements Node {
  active: Boolean!
  "Account controlling the document"
  author: CeramicAccount!
  content: [AkashaBeamBlockRecord!]!
  createdAt: DateTime!
  embeddedBeam: CeramicStreamID
  id: ID!
  mentions: [CeramicStreamID]
  reflections(
    "Returns only documents created by the provided account"
    account: ID,
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaReflectFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaReflectSortingInput
  ): AkashaReflectConnection!
  reflectionsCount(
    "Counts only documents created by the provided account"
    account: ID,
    filters: AkashaReflectFiltersInput
  ): Int!
  tags: [String]
  "Current version of the document"
  version: CeramicCommitID!
}

type AkashaBeamBlockRecord {
  blockID: CeramicStreamID!
  order: Int!
}

"A connection to a list of items."
type AkashaBeamConnection {
  "A list of edges."
  edges: [AkashaBeamEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaBeamEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaBeam
}

type AkashaBlockStorage implements Node {
  active: Boolean!
  appVersion: AkashaAppRelease
  appVersionID: CeramicStreamID!
  "Account controlling the document"
  author: CeramicAccount!
  block: AkashaContentBlock
  blockID: CeramicStreamID!
  content: [AkashaBlockStorageLabeledValue!]!
  createdAt: DateTime!
  id: ID!
  kind: AkashaBlockStorageBlockStorageDef
  "Current version of the document"
  version: CeramicCommitID!
}

"A connection to a list of items."
type AkashaBlockStorageConnection {
  "A list of edges."
  edges: [AkashaBlockStorageEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaBlockStorageEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaBlockStorage
}

type AkashaBlockStorageLabeledValue {
  label: String!
  propertyType: String!
  value: String!
}

type AkashaContentBlock implements Node {
  active: Boolean!
  appVersion: AkashaAppRelease
  appVersionID: CeramicStreamID!
  "Account controlling the document"
  author: CeramicAccount!
  content: [AkashaContentBlockLabeledValue!]!
  createdAt: DateTime!
  id: ID!
  kind: AkashaContentBlockBlockDef
  "Current version of the document"
  version: CeramicCommitID!
}

"A connection to a list of items."
type AkashaContentBlockConnection {
  "A list of edges."
  edges: [AkashaContentBlockEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaContentBlockEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaContentBlock
}

type AkashaContentBlockLabeledValue {
  label: String!
  propertyType: String!
  value: String!
}

type AkashaFollow implements Node {
  "Account controlling the document"
  did: CeramicAccount!
  id: ID!
  isFollowing: Boolean!
  profile: AkashaProfile
  profileID: CeramicStreamID!
}

"A connection to a list of items."
type AkashaFollowConnection {
  "A list of edges."
  edges: [AkashaFollowEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaFollowEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaFollow
}

type AkashaProfile implements Node {
  avatar: AkashaProfileImageVersions
  background: AkashaProfileImageVersions
  createdAt: DateTime!
  description: String
  "Account controlling the document"
  did: CeramicAccount!
  followers(
    "Returns only documents created by the provided account"
    account: ID,
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaFollowFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaFollowSortingInput
  ): AkashaFollowConnection!
  id: ID!
  links: [AkashaProfileLinkSource]
  name: String!
}

"A connection to a list of items."
type AkashaProfileConnection {
  "A list of edges."
  edges: [AkashaProfileEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaProfileEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaProfile
}

type AkashaProfileImageSource {
  height: Int!
  src: URI!
  width: Int!
}

type AkashaProfileImageVersions {
  alternatives: [AkashaProfileImageSource]
  default: AkashaProfileImageSource!
}

type AkashaProfileInterests implements Node {
  "Account controlling the document"
  did: CeramicAccount!
  id: ID!
  topics: [AkashaProfileInterestsLabeled!]!
}

"A connection to a list of items."
type AkashaProfileInterestsConnection {
  "A list of edges."
  edges: [AkashaProfileInterestsEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaProfileInterestsEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaProfileInterests
}

type AkashaProfileInterestsLabeled {
  labelType: String!
  value: String!
}

type AkashaProfileLinkSource {
  href: URI!
  label: String
}

type AkashaReflect implements Node {
  active: Boolean!
  "Account controlling the document"
  author: CeramicAccount!
  beam: AkashaBeam
  beamID: CeramicStreamID!
  content: [AkashaReflectProviderValue!]!
  createdAt: DateTime!
  id: ID!
  isReply: Boolean!
  mentions: [CeramicStreamID]
  reflection: CeramicStreamID
  tags: [String]
  "Current version of the document"
  version: CeramicCommitID!
}

"A connection to a list of items."
type AkashaReflectConnection {
  "A list of edges."
  edges: [AkashaReflectEdge]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AkashaReflectEdge {
  "A cursor for use in pagination"
  cursor: String!
  "The item at the end of the edge"
  node: AkashaReflect
}

type AkashaReflectProviderValue {
  property: String!
  provider: String!
  value: String!
}

type CeramicAccount implements Node {
  akashaAppList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaAppFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaAppSortingInput
  ): AkashaAppConnection
  akashaAppReleaseList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaAppReleaseFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaAppReleaseSortingInput
  ): AkashaAppReleaseConnection
  akashaBeamList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaBeamFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaBeamSortingInput
  ): AkashaBeamConnection
  akashaBlockStorageList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaBlockStorageFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaBlockStorageSortingInput
  ): AkashaBlockStorageConnection
  akashaContentBlockList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaContentBlockFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaContentBlockSortingInput
  ): AkashaContentBlockConnection
  akashaFollowList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaFollowFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaFollowSortingInput
  ): AkashaFollowConnection
  akashaProfile: AkashaProfile
  akashaProfileInterests: AkashaProfileInterests
  akashaReflectList(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaReflectFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaReflectSortingInput
  ): AkashaReflectConnection
  "Globally unique identifier of the account (DID string)"
  id: ID!
  "Whether the Ceramic instance is currently authenticated with this account or not"
  isViewer: Boolean!
}

type CreateAkashaAppPayload {
  clientMutationId: String
  document: AkashaApp!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type CreateAkashaAppReleasePayload {
  clientMutationId: String
  document: AkashaAppRelease!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type CreateAkashaBeamPayload {
  clientMutationId: String
  document: AkashaBeam!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type CreateAkashaBlockStoragePayload {
  clientMutationId: String
  document: AkashaBlockStorage!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type CreateAkashaContentBlockPayload {
  clientMutationId: String
  document: AkashaContentBlock!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type CreateAkashaFollowPayload {
  clientMutationId: String
  document: AkashaFollow!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type CreateAkashaProfileInterestsPayload {
  clientMutationId: String
  document: AkashaProfileInterests!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type CreateAkashaProfilePayload {
  clientMutationId: String
  document: AkashaProfile!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type CreateAkashaReflectPayload {
  clientMutationId: String
  document: AkashaReflect!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type Mutation {
  createAkashaApp(input: CreateAkashaAppInput!): CreateAkashaAppPayload
  createAkashaAppRelease(input: CreateAkashaAppReleaseInput!): CreateAkashaAppReleasePayload
  createAkashaBeam(input: CreateAkashaBeamInput!): CreateAkashaBeamPayload
  createAkashaBlockStorage(input: CreateAkashaBlockStorageInput!): CreateAkashaBlockStoragePayload
  createAkashaContentBlock(input: CreateAkashaContentBlockInput!): CreateAkashaContentBlockPayload
  createAkashaFollow(input: CreateAkashaFollowInput!): CreateAkashaFollowPayload
  createAkashaProfile(input: CreateAkashaProfileInput!): CreateAkashaProfilePayload
  createAkashaProfileInterests(input: CreateAkashaProfileInterestsInput!): CreateAkashaProfileInterestsPayload
  createAkashaReflect(input: CreateAkashaReflectInput!): CreateAkashaReflectPayload
  updateAkashaApp(input: UpdateAkashaAppInput!): UpdateAkashaAppPayload
  updateAkashaAppRelease(input: UpdateAkashaAppReleaseInput!): UpdateAkashaAppReleasePayload
  updateAkashaBeam(input: UpdateAkashaBeamInput!): UpdateAkashaBeamPayload
  updateAkashaBlockStorage(input: UpdateAkashaBlockStorageInput!): UpdateAkashaBlockStoragePayload
  updateAkashaContentBlock(input: UpdateAkashaContentBlockInput!): UpdateAkashaContentBlockPayload
  updateAkashaFollow(input: UpdateAkashaFollowInput!): UpdateAkashaFollowPayload
  updateAkashaProfile(input: UpdateAkashaProfileInput!): UpdateAkashaProfilePayload
  updateAkashaProfileInterests(input: UpdateAkashaProfileInterestsInput!): UpdateAkashaProfileInterestsPayload
  updateAkashaReflect(input: UpdateAkashaReflectInput!): UpdateAkashaReflectPayload
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

type Query {
  akashaAppIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaAppFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaAppSortingInput
  ): AkashaAppConnection
  akashaAppReleaseIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaAppReleaseFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaAppReleaseSortingInput
  ): AkashaAppReleaseConnection
  akashaBeamIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaBeamFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaBeamSortingInput
  ): AkashaBeamConnection
  akashaBlockStorageIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaBlockStorageFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaBlockStorageSortingInput
  ): AkashaBlockStorageConnection
  akashaContentBlockIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaContentBlockFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaContentBlockSortingInput
  ): AkashaContentBlockConnection
  akashaFollowIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaFollowFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaFollowSortingInput
  ): AkashaFollowConnection
  akashaProfileIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaProfileFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaProfileSortingInput
  ): AkashaProfileConnection
  akashaProfileInterestsIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int
  ): AkashaProfileInterestsConnection
  akashaReflectIndex(
    "Returns the items in the list that come after the specified cursor."
    after: String,
    "Returns the items in the list that come before the specified cursor."
    before: String,
    filters: AkashaReflectFiltersInput,
    "Returns the first n items from the list."
    first: Int,
    "Returns the last n items from the list."
    last: Int,
    sorting: AkashaReflectSortingInput
  ): AkashaReflectConnection
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaAppPayload {
  clientMutationId: String
  document: AkashaApp!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaAppReleasePayload {
  clientMutationId: String
  document: AkashaAppRelease!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaBeamPayload {
  clientMutationId: String
  document: AkashaBeam!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaBlockStoragePayload {
  clientMutationId: String
  document: AkashaBlockStorage!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaContentBlockPayload {
  clientMutationId: String
  document: AkashaContentBlock!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaFollowPayload {
  clientMutationId: String
  document: AkashaFollow!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaProfileInterestsPayload {
  clientMutationId: String
  document: AkashaProfileInterests!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaProfilePayload {
  clientMutationId: String
  document: AkashaProfile!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

type UpdateAkashaReflectPayload {
  clientMutationId: String
  document: AkashaReflect!
  "Fetches an object given its ID"
  node(
    "The ID of an object"
    id: ID!
  ): Node
  "Account currently authenticated on the Ceramic instance, if set"
  viewer: CeramicAccount
}

enum AkashaAppApplicationType {
  APP
  OTHER
  PLUGIN
  WIDGET
}

enum AkashaBlockStorageBlockStorageDef {
  BOOL
  EMOJI
  FORM_DATA
  OTHER
  TEXT
}

enum AkashaContentBlockBlockDef {
  FORM
  OTHER
  TEXT
}

enum SortOrder {
  ASC
  DESC
}

"A Ceramic Commit ID"
scalar CeramicCommitID

"A Ceramic Stream ID"
scalar CeramicStreamID

"A field whose value conforms to the standard DID format as specified in did-core: https://www.w3.org/TR/did-core/."
scalar DID

"A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."
scalar DateTime

"A IPLD CID"
scalar InterPlanetaryCID

"A field whose value conforms to the standard Uniform Resource Identifier (URI) format as specified in RFC3986."
scalar URI

input AkashaAppApplicationTypeValueFilterInput {
  equalTo: AkashaAppApplicationType
  in: [AkashaAppApplicationType!]
  isNull: Boolean
  notEqualTo: AkashaAppApplicationType
  notIn: [AkashaAppApplicationType!]
}

input AkashaAppFiltersInput {
  and: [AkashaAppFiltersInput!]
  not: AkashaAppFiltersInput
  or: [AkashaAppFiltersInput!]
  where: AkashaAppObjectFilterInput
}

input AkashaAppInput {
  applicationType: AkashaAppApplicationType
  contributors: [DID]
  createdAt: DateTime!
  description: String!
  displayName: String!
  keywords: [String]
  licence: String!
  name: String!
}

input AkashaAppObjectFilterInput {
  applicationType: AkashaAppApplicationTypeValueFilterInput
  createdAt: StringValueFilterInput
  displayName: StringValueFilterInput
  name: StringValueFilterInput
}

input AkashaAppReleaseFiltersInput {
  and: [AkashaAppReleaseFiltersInput!]
  not: AkashaAppReleaseFiltersInput
  or: [AkashaAppReleaseFiltersInput!]
  where: AkashaAppReleaseObjectFilterInput
}

input AkashaAppReleaseInput {
  applicationID: CeramicStreamID!
  createdAt: DateTime!
  source: InterPlanetaryCID!
  version: String!
}

input AkashaAppReleaseObjectFilterInput {
  createdAt: StringValueFilterInput
  version: StringValueFilterInput
}

input AkashaAppReleaseSortingInput {
  createdAt: SortOrder
  version: SortOrder
}

input AkashaAppSortingInput {
  applicationType: SortOrder
  createdAt: SortOrder
  displayName: SortOrder
  name: SortOrder
}

input AkashaBeamBlockRecordInput {
  blockID: CeramicStreamID!
  order: Int!
}

input AkashaBeamFiltersInput {
  and: [AkashaBeamFiltersInput!]
  not: AkashaBeamFiltersInput
  or: [AkashaBeamFiltersInput!]
  where: AkashaBeamObjectFilterInput
}

input AkashaBeamInput {
  active: Boolean!
  content: [AkashaBeamBlockRecordInput]!
  createdAt: DateTime!
  embeddedBeam: CeramicStreamID
  mentions: [CeramicStreamID]
  tags: [String]
}

input AkashaBeamObjectFilterInput {
  active: BooleanValueFilterInput
  createdAt: StringValueFilterInput
}

input AkashaBeamSortingInput {
  active: SortOrder
  createdAt: SortOrder
}

input AkashaBlockStorageBlockStorageDefValueFilterInput {
  equalTo: AkashaBlockStorageBlockStorageDef
  in: [AkashaBlockStorageBlockStorageDef!]
  isNull: Boolean
  notEqualTo: AkashaBlockStorageBlockStorageDef
  notIn: [AkashaBlockStorageBlockStorageDef!]
}

input AkashaBlockStorageFiltersInput {
  and: [AkashaBlockStorageFiltersInput!]
  not: AkashaBlockStorageFiltersInput
  or: [AkashaBlockStorageFiltersInput!]
  where: AkashaBlockStorageObjectFilterInput
}

input AkashaBlockStorageInput {
  active: Boolean!
  appVersionID: CeramicStreamID!
  blockID: CeramicStreamID!
  content: [AkashaBlockStorageLabeledValueInput]!
  createdAt: DateTime!
  kind: AkashaBlockStorageBlockStorageDef
}

input AkashaBlockStorageLabeledValueInput {
  label: String!
  propertyType: String!
  value: String!
}

input AkashaBlockStorageObjectFilterInput {
  active: BooleanValueFilterInput
  createdAt: StringValueFilterInput
  kind: AkashaBlockStorageBlockStorageDefValueFilterInput
}

input AkashaBlockStorageSortingInput {
  active: SortOrder
  createdAt: SortOrder
  kind: SortOrder
}

input AkashaContentBlockBlockDefValueFilterInput {
  equalTo: AkashaContentBlockBlockDef
  in: [AkashaContentBlockBlockDef!]
  isNull: Boolean
  notEqualTo: AkashaContentBlockBlockDef
  notIn: [AkashaContentBlockBlockDef!]
}

input AkashaContentBlockFiltersInput {
  and: [AkashaContentBlockFiltersInput!]
  not: AkashaContentBlockFiltersInput
  or: [AkashaContentBlockFiltersInput!]
  where: AkashaContentBlockObjectFilterInput
}

input AkashaContentBlockInput {
  active: Boolean!
  appVersionID: CeramicStreamID!
  content: [AkashaContentBlockLabeledValueInput]!
  createdAt: DateTime!
  kind: AkashaContentBlockBlockDef
}

input AkashaContentBlockLabeledValueInput {
  label: String!
  propertyType: String!
  value: String!
}

input AkashaContentBlockObjectFilterInput {
  active: BooleanValueFilterInput
  createdAt: StringValueFilterInput
  kind: AkashaContentBlockBlockDefValueFilterInput
}

input AkashaContentBlockSortingInput {
  active: SortOrder
  createdAt: SortOrder
  kind: SortOrder
}

input AkashaFollowFiltersInput {
  and: [AkashaFollowFiltersInput!]
  not: AkashaFollowFiltersInput
  or: [AkashaFollowFiltersInput!]
  where: AkashaFollowObjectFilterInput
}

input AkashaFollowInput {
  isFollowing: Boolean!
  profileID: CeramicStreamID!
}

input AkashaFollowObjectFilterInput {
  isFollowing: BooleanValueFilterInput
}

input AkashaFollowSortingInput {
  isFollowing: SortOrder
}

input AkashaProfileFiltersInput {
  and: [AkashaProfileFiltersInput!]
  not: AkashaProfileFiltersInput
  or: [AkashaProfileFiltersInput!]
  where: AkashaProfileObjectFilterInput
}

input AkashaProfileImageSourceInput {
  height: Int!
  src: URI!
  width: Int!
}

input AkashaProfileImageVersionsInput {
  alternatives: [AkashaProfileImageSourceInput]
  default: AkashaProfileImageSourceInput!
}

input AkashaProfileInput {
  avatar: AkashaProfileImageVersionsInput
  background: AkashaProfileImageVersionsInput
  createdAt: DateTime!
  description: String
  links: [AkashaProfileLinkSourceInput]
  name: String!
}

input AkashaProfileInterestsInput {
  topics: [AkashaProfileInterestsLabeledInput]!
}

input AkashaProfileInterestsLabeledInput {
  labelType: String!
  value: String!
}

input AkashaProfileLinkSourceInput {
  href: URI!
  label: String
}

input AkashaProfileObjectFilterInput {
  createdAt: StringValueFilterInput
  name: StringValueFilterInput
}

input AkashaProfileSortingInput {
  createdAt: SortOrder
  name: SortOrder
}

input AkashaReflectFiltersInput {
  and: [AkashaReflectFiltersInput!]
  not: AkashaReflectFiltersInput
  or: [AkashaReflectFiltersInput!]
  where: AkashaReflectObjectFilterInput
}

input AkashaReflectInput {
  active: Boolean!
  beamID: CeramicStreamID!
  content: [AkashaReflectProviderValueInput]!
  createdAt: DateTime!
  isReply: Boolean!
  mentions: [CeramicStreamID]
  reflection: CeramicStreamID
  tags: [String]
}

input AkashaReflectObjectFilterInput {
  active: BooleanValueFilterInput
  createdAt: StringValueFilterInput
  isReply: BooleanValueFilterInput
  reflection: StringValueFilterInput
}

input AkashaReflectProviderValueInput {
  property: String!
  provider: String!
  value: String!
}

input AkashaReflectSortingInput {
  active: SortOrder
  createdAt: SortOrder
  isReply: SortOrder
  reflection: SortOrder
}

input BooleanValueFilterInput {
  equalTo: Boolean
  isNull: Boolean
}

input CreateAkashaAppInput {
  clientMutationId: String
  content: AkashaAppInput!
}

input CreateAkashaAppReleaseInput {
  clientMutationId: String
  content: AkashaAppReleaseInput!
}

input CreateAkashaBeamInput {
  clientMutationId: String
  content: AkashaBeamInput!
}

input CreateAkashaBlockStorageInput {
  clientMutationId: String
  content: AkashaBlockStorageInput!
}

input CreateAkashaContentBlockInput {
  clientMutationId: String
  content: AkashaContentBlockInput!
}

input CreateAkashaFollowInput {
  clientMutationId: String
  content: AkashaFollowInput!
}

input CreateAkashaProfileInput {
  clientMutationId: String
  content: AkashaProfileInput!
}

input CreateAkashaProfileInterestsInput {
  clientMutationId: String
  content: AkashaProfileInterestsInput!
}

input CreateAkashaReflectInput {
  clientMutationId: String
  content: AkashaReflectInput!
}

input PartialAkashaAppInput {
  applicationType: AkashaAppApplicationType
  contributors: [DID]
  createdAt: DateTime
  description: String
  displayName: String
  keywords: [String]
  licence: String
  name: String
}

input PartialAkashaAppReleaseInput {
  applicationID: CeramicStreamID
  createdAt: DateTime
  source: InterPlanetaryCID
  version: String
}

input PartialAkashaBeamInput {
  active: Boolean
  content: [AkashaBeamBlockRecordInput]
  createdAt: DateTime
  embeddedBeam: CeramicStreamID
  mentions: [CeramicStreamID]
  tags: [String]
}

input PartialAkashaBlockStorageInput {
  active: Boolean
  appVersionID: CeramicStreamID
  blockID: CeramicStreamID
  content: [AkashaBlockStorageLabeledValueInput]
  createdAt: DateTime
  kind: AkashaBlockStorageBlockStorageDef
}

input PartialAkashaContentBlockInput {
  active: Boolean
  appVersionID: CeramicStreamID
  content: [AkashaContentBlockLabeledValueInput]
  createdAt: DateTime
  kind: AkashaContentBlockBlockDef
}

input PartialAkashaFollowInput {
  isFollowing: Boolean
  profileID: CeramicStreamID
}

input PartialAkashaProfileInput {
  avatar: AkashaProfileImageVersionsInput
  background: AkashaProfileImageVersionsInput
  createdAt: DateTime
  description: String
  links: [AkashaProfileLinkSourceInput]
  name: String
}

input PartialAkashaProfileInterestsInput {
  topics: [AkashaProfileInterestsLabeledInput]
}

input PartialAkashaReflectInput {
  active: Boolean
  beamID: CeramicStreamID
  content: [AkashaReflectProviderValueInput]
  createdAt: DateTime
  isReply: Boolean
  mentions: [CeramicStreamID]
  reflection: CeramicStreamID
  tags: [String]
}

input StringValueFilterInput {
  equalTo: String
  greaterThan: String
  greaterThanOrEqualTo: String
  in: [String!]
  isNull: Boolean
  lessThan: String
  lessThanOrEqualTo: String
  notEqualTo: String
  notIn: [String!]
}

input UpdateAkashaAppInput {
  clientMutationId: String
  content: PartialAkashaAppInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaAppReleaseInput {
  clientMutationId: String
  content: PartialAkashaAppReleaseInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaBeamInput {
  clientMutationId: String
  content: PartialAkashaBeamInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaBlockStorageInput {
  clientMutationId: String
  content: PartialAkashaBlockStorageInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaContentBlockInput {
  clientMutationId: String
  content: PartialAkashaContentBlockInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaFollowInput {
  clientMutationId: String
  content: PartialAkashaFollowInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaProfileInput {
  clientMutationId: String
  content: PartialAkashaProfileInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaProfileInterestsInput {
  clientMutationId: String
  content: PartialAkashaProfileInterestsInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateAkashaReflectInput {
  clientMutationId: String
  content: PartialAkashaReflectInput!
  id: ID!
  options: UpdateOptionsInput
}

input UpdateOptionsInput {
  "Fully replace the document contents instead of performing a shallow merge"
  replace: Boolean = false
  "Only perform mutation if the document matches the provided version"
  version: CeramicCommitID
}
