{
  "language": "Solidity",
  "sources": {
    "contracts/AbstractSubdomainRegistrar.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"@ensdomains/ens/contracts/ENS.sol\";\nimport \"@ensdomains/ens/contracts/ReverseRegistrar.sol\";\nimport \"@ensdomains/resolver/contracts/Resolver.sol\";\n\ncontract AbstractSubdomainRegistrar {\n\n    // namehash('eth')\n    bytes32 constant public TLD_NODE = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    // namehash('akasha.eth')\n    bytes32 constant public ROOT_NODE = 0x43bba60d9ee890bd3cd87a2a11df3f21a591ec3a99af5532f3795352370d266b;\n\n    bool public stopped = false;\n    address public registrarOwner;\n\n    address public registrar;\n\n\n    ENS public ens;\n\n    modifier owner_only(bytes32 label) {\n        require(owner(label) == msg.sender);\n        _;\n    }\n\n    modifier not_stopped() {\n        require(!stopped);\n        _;\n    }\n\n    modifier registrar_owner_only() {\n        require(msg.sender == registrarOwner);\n        _;\n    }\n\n    constructor(ENS _ens) public {\n        ens = _ens;\n        registrar = ens.owner(TLD_NODE);\n        registrarOwner = msg.sender;\n    }\n\n    function doRegistration(bytes32 node, bytes32 label, address subdomainOwner, Resolver resolver) internal {\n        // Get the subdomain so we can configure it\n        ens.setSubnodeOwner(node, label, address(this));\n\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\n        // Set the subdomain's resolver\n        ens.setResolver(subnode, address(resolver));\n\n        // Set the address record on the resolver\n        resolver.setAddr(subnode, subdomainOwner);\n\n        // Pass ownership of the new subdomain to the registrant\n        ens.setOwner(subnode, subdomainOwner);\n    }\n\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n        return (\n            (interfaceID == 0x01ffc9a7) // supportsInterface(bytes4)\n            || (interfaceID == 0xc1b15f5a) // RegistrarInterface\n        );\n    }\n\n    /**\n     * @dev Stops the registrar, disabling configuring of new domains.\n     */\n    function stop() public not_stopped registrar_owner_only {\n        stopped = true;\n    }\n\n    function transferOwnership(address newOwner) public registrar_owner_only {\n        registrarOwner = newOwner;\n    }\n\n    function reclaimRoot() public registrar_owner_only {\n        ens.setOwner(ROOT_NODE, registrarOwner);\n    }\n\n    function owner(bytes32 label) public view returns (address);\n}\n"
    },
    "@ensdomains/ens/contracts/ENS.sol": {
      "content": "pragma solidity >=0.4.24;\n\ninterface ENS {\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns(bytes32);\n    function setResolver(bytes32 node, address resolver) external;\n    function setOwner(bytes32 node, address owner) external;\n    function setTTL(bytes32 node, uint64 ttl) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function owner(bytes32 node) external view returns (address);\n    function resolver(bytes32 node) external view returns (address);\n    function ttl(bytes32 node) external view returns (uint64);\n    function recordExists(bytes32 node) external view returns (bool);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@ensdomains/ens/contracts/ReverseRegistrar.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ENS.sol\";\n\ncontract NameResolver {\n    function setName(bytes32 node, string memory name) public;\n}\n\ncontract ReverseRegistrar {\n    // namehash('addr.reverse')\n    bytes32 public constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    ENS public ens;\n    NameResolver public defaultResolver;\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     * @param resolverAddr The address of the default reverse resolver.\n     */\n    constructor(ENS ensAddr, NameResolver resolverAddr) public {\n        ens = ensAddr;\n        defaultResolver = resolverAddr;\n\n        // Assign ownership of the reverse record to our deployer\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(ens.owner(ADDR_REVERSE_NODE));\n        if (address(oldRegistrar) != address(0x0)) {\n            oldRegistrar.claim(msg.sender);\n        }\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claim(address owner) public returns (bytes32) {\n        return claimWithResolver(owner, address(0x0));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimWithResolver(address owner, address resolver) public returns (bytes32) {\n        bytes32 label = sha3HexAddress(msg.sender);\n        bytes32 node = keccak256(abi.encodePacked(ADDR_REVERSE_NODE, label));\n        address currentOwner = ens.owner(node);\n\n        // Update the resolver if required\n        if (resolver != address(0x0) && resolver != ens.resolver(node)) {\n            // Transfer the name to us first if it's not already\n            if (currentOwner != address(this)) {\n                ens.setSubnodeOwner(ADDR_REVERSE_NODE, label, address(this));\n                currentOwner = address(this);\n            }\n            ens.setResolver(node, resolver);\n        }\n\n        // Update the owner if required\n        if (currentOwner != owner) {\n            ens.setSubnodeOwner(ADDR_REVERSE_NODE, label, owner);\n        }\n\n        return node;\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setName(string memory name) public returns (bytes32) {\n        bytes32 node = claimWithResolver(address(this), address(defaultResolver));\n        defaultResolver.setName(node, name);\n        return node;\n    }\n\n    /**\n     * @dev Returns the node hash for a given account's reverse records.\n     * @param addr The address to hash\n     * @return The ENS node hash.\n     */\n    function node(address addr) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr)));\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        addr;\n        ret; // Stop warning us about unused variables\n        assembly {\n            let lookup := 0x3031323334353637383961626364656600000000000000000000000000000000\n\n            for { let i := 40 } gt(i, 0) { } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n}\n"
    },
    "@ensdomains/resolver/contracts/Resolver.sol": {
      "content": "pragma solidity >=0.4.25;\npragma experimental ABIEncoderV2;\n\n/**\n * A generic resolver interface which includes all the functions including the ones deprecated\n */\ninterface Resolver{\n    event AddrChanged(bytes32 indexed node, address a);\n    event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\n    event NameChanged(bytes32 indexed node, string name);\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);\n    function addr(bytes32 node) external view returns (address);\n    function addr(bytes32 node, uint coinType) external view returns(bytes memory);\n    function contenthash(bytes32 node) external view returns (bytes memory);\n    function dnsrr(bytes32 node) external view returns (bytes memory);\n    function name(bytes32 node) external view returns (string memory);\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\n    function text(bytes32 node, string calldata key) external view returns (string memory);\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external;\n    function setAddr(bytes32 node, address addr) external;\n    function setAddr(bytes32 node, uint coinType, bytes calldata a) external;\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n    function setName(bytes32 node, string calldata _name) external;\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n    function setText(bytes32 node, string calldata key, string calldata value) external;\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external;\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool);\n    function multicall(bytes[] calldata data) external returns(bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n    function multihash(bytes32 node) external view returns (bytes memory);\n    function setContent(bytes32 node, bytes32 hash) external;\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}\n"
    },
    "contracts/AkashaRegistrar.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./AbstractSubdomainRegistrar.sol\";\nimport \"@ensdomains/ens/contracts/Registrar.sol\";\nimport \"@ensdomains/ens/contracts/ReverseRegistrar.sol\";\nimport \"@ensdomains/resolver/contracts/Resolver.sol\";\n\ncontract AkashaRegistrar is AbstractSubdomainRegistrar {\n\n\n    modifier new_registrar() {\n        require(ens.owner(ROOT_NODE) != address(registrar));\n        _;\n    }\n\n    event AkashaName(bytes32 indexed label, string name);\n\n    constructor(ENS ens) AbstractSubdomainRegistrar(ens) public { }\n\n    /**\n     * @dev owner returns the address of the account that controls a subdomain.\n     * @param label The label hash of the deed to check.\n     * @return The address owning the subdomain/label.\n     */\n    function owner(bytes32 label) public view returns (address) {\n        return ens.owner(keccak256(abi.encodePacked(ROOT_NODE, label)));\n    }\n\n    /**\n    * @dev Checks if a subdomain is registered\n    * @param subdomain The subdomain to check\n    */\n    function isAvailable(string memory subdomain) public view returns (bool) {\n        bytes32 subdomainLabel = keccak256(bytes(subdomain));\n        return ens.owner(keccak256(abi.encodePacked(ROOT_NODE, subdomainLabel))) == address(0);\n    }\n\n    /**\n     * @dev Registers a subdomain.\n     * @param subdomain The desired subdomain label.\n     */\n    function register(string calldata subdomain, address resolver) external not_stopped {\n        address subdomainOwner = msg.sender;\n        bytes32 subdomainLabel = keccak256(bytes(subdomain));\n\n        // Subdomain must not be registered already.\n        require(ens.owner(keccak256(abi.encodePacked(ROOT_NODE, subdomainLabel))) == address(0));\n\n        doRegistration(ROOT_NODE, subdomainLabel, subdomainOwner, Resolver(resolver));\n        // Register the reverse, it doesn't work because of msg.sender\n        // string memory domain = \".akasha.eth\";\n        // bytes32 node = ReverseRegistrar(reverseRegistrar).claimWithResolver(msg.sender, resolver);\n        // add a friendly name to the reversed node hash\n        // Resolver(resolver).setName(node, string(abi.encodePacked(subdomain, domain)));\n        emit AkashaName(subdomainLabel, subdomain);\n    }\n\n}\n"
    },
    "@ensdomains/ens/contracts/Registrar.sol": {
      "content": "pragma solidity >=0.4.24;\n\nimport \"./Deed.sol\";\n\ninterface Registrar {\n\n    enum Mode { Open, Auction, Owned, Forbidden, Reveal, NotYetAvailable }\n\n    event AuctionStarted(bytes32 indexed hash, uint registrationDate);\n    event NewBid(bytes32 indexed hash, address indexed bidder, uint deposit);\n    event BidRevealed(bytes32 indexed hash, address indexed owner, uint value, uint8 status);\n    event HashRegistered(bytes32 indexed hash, address indexed owner, uint value, uint registrationDate);\n    event HashReleased(bytes32 indexed hash, uint value);\n    event HashInvalidated(bytes32 indexed hash, string indexed name, uint value, uint registrationDate);\n\n    function state(bytes32 _hash) external view returns (Mode);\n    function startAuction(bytes32 _hash) external;\n    function startAuctions(bytes32[] calldata _hashes) external;\n    function newBid(bytes32 sealedBid) external payable;\n    function startAuctionsAndBid(bytes32[] calldata hashes, bytes32 sealedBid) external payable;\n    function unsealBid(bytes32 _hash, uint _value, bytes32 _salt) external;\n    function cancelBid(address bidder, bytes32 seal) external;\n    function finalizeAuction(bytes32 _hash) external;\n    function transfer(bytes32 _hash, address payable newOwner) external;\n    function releaseDeed(bytes32 _hash) external;\n    function invalidateName(string calldata unhashedName) external;\n    function eraseNode(bytes32[] calldata labels) external;\n    function transferRegistrars(bytes32 _hash) external;\n    function acceptRegistrarTransfer(bytes32 hash, Deed deed, uint registrationDate) external;\n    function entries(bytes32 _hash) external view returns (Mode, address, uint, uint, uint);\n}\n"
    },
    "@ensdomains/ens/contracts/Deed.sol": {
      "content": "pragma solidity >=0.4.24;\n\ninterface Deed {\n\n    function setOwner(address payable newOwner) external;\n    function setRegistrar(address newRegistrar) external;\n    function setBalance(uint newValue, bool throwOnFailure) external;\n    function closeDeed(uint refundRatio) external;\n    function destroyDeed() external;\n\n    function owner() external view returns (address);\n    function previousOwner() external view returns (address);\n    function value() external view returns (uint);\n    function creationDate() external view returns (uint);\n\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}